{
  "createdAt": 1652328797208,
  "updatedAt": 1652339528367,
  "thumbnail": "https://academy.sentre.io/static/media/ds-thumbnail.4bb629ac92820acea899.png",
  "category": [
    "dev"
  ],
  "en": {
    "contents": "Sau khi hoàn thành 5 bài đầu tiên trong chuỗi 10 bài, chúng ta đã được trang bị các kiến thức cơ bản nhất để xây dựng một DApp hoàn chỉnh. Để giúp bạn đọc có thể hệ thống lại kiến thức, bài viết xin nhắc lại các kiến thức đã học gồm:\n\n* ReactJS - giúp phát triển ứng dụng nền Web.\n* Ant Design - giúp xây dựng nhanh chóng giao diện người dùng bằng các thành phần dựng sẵn.\n* Redux Toolkit - giúp quản lý trạng thái của ứng dụng với số lượng dữ liệu và trạng thái phức tạp.\n* Anchor - giúp phát triển chương trình chạy được trên chuỗi khối. Solana dùng thuật ngữ program, hoặc Ethereum dùng thuật ngữ smart contract để ám chỉ chương trình này.\n\nTrong bài này chúng ta sẽ kết hợp tất cả chúng lại để xây dựng một ứng dụng bỏ phiếu một cách hoàn chỉnh nhất.\n\n## **Hệ thống bỏ phiếu điện tử có trọng số (Weighted eVoting System)**\nTrong phần này chúng ta sẽ đi phân tích xem để hiểu được hệ thống bỏ phiếu điện tử có trọng số (sau đây sẽ gọi ngắn gọn là hệ thống) có những đặc tính cơ bản nào.\n\n### **Phiếu bầu có trọng số**\nĐối với các hệ thống bỏ phiếu phổ biến, đa số chúng đều là không trọng số. Nghĩa là mọi người bỏ phiếu (voter) đều có “sức mạnh” như nhau và bằng chính xác 1 lá phiếu. Dù bạn rất nổi tiếng, hay bạn là một sinh viên, thì lá phiếu của bạn đều chỉ được tính là 1. Ngược lại, trong hệ thống có trọng số, yếu tố “sức mạnh” được xem xét đến trong quá trình kiểm phiếu. Cụ thể hơn,\n\ntrên môi trường blockchain, số lượng một token cụ thể bạn đang nắm sẽ đại diện cho sức mạnh lá phiếu của bạn.\n\n* hình 1, người bỏ phiếu có 10 tokens và anh ấy có thể dùng 10 tokens đó để đại diện cho “sức mạnh” lá phiếu bầu. Ví dụ, anh ấy bỏ phiếu cho Candidate #1, thì hệ thống sẽ ghi nhận Cadidate #1 được cộng thêm 10 điểm.\n\n\n![](https://academy.sentre.io/static/media/post-5-weight.46eaad4973b1f98b7529.png)\n### **Double Spend**\nDouble Spend hay “Dùng hai lần” là một hình thức gian lận giúp người dùng có thể sử dụng nhiều hơn một lần bằng 1 số lượng tokens cụ thể. Trong phạm vi hệ thống, sử dụng được hiểu theo nghĩa là bỏ phiếu. Giả sử như sau khi bỏ phiếu bằng ví số 1, người dùng cố tình chuyển số tokens ban đầu sang một ví số 2 nhằm thực hiện lại hành vi bỏ phiếu không hợp lệ. Tiếp tục như vậy, với chỉ 10 tokens, người dùng có thể bỏ phiếu vô số lần.\n\nĐể đảm bảo được tính công bằng, với mỗi lượt bỏ phiếu, số token của người dùng phải được khoá trong thời gian bỏ phiếu. Cơ chế khoá được hiện thực đơn giản bằng cách chuyển token người dùng vào một ví tạm thời và chỉ hệ thống mới có thể kiểm soát ví đó. Hết thời hạn bỏ phiếu, số token sẽ được trả lại chính xác cho người bỏ phiếu.\n\n \n\n![](https://academy.sentre.io/static/media/post-5-weight-2.8ba8bcc02fe2f5db029b.png)\n*Hình 2. Token người dùng sẽ được khoá tạm thời trong thời gian bỏ phiếu. Số token này sẽ đc hoàn trả khi kết thúc bỏ phiếu.*\n\n## **Hiện thực hệ thống**\n### **Khai báo Schema**\n#### **Candidate**\n\nMỗi ứng viên sẽ được tạo một tài khoản trên chuỗi khối nhằm ghi nhận số lượng người bỏ phiếu cũng như quản lý các thông tin cần thiết cho việc bỏ phiếu. Để cho đơn giản, ở đây bài viết lược bỏ đi khá nhiều thông tin và chỉ giữ lại các thông tin cơ bản nhất.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-3.43baaffb217762c92a1f.png\">\n</p>\n\n*Hình 3. Thông tin ứng viên (Candidate schema)*\n\n* mint: Loại token được dùng để bỏ phiếu.\n* amount: số lượng token bầu cho ứng viên.\n* start_date: Thời gian bắt đầu cho phép bỏ phiếu\n* end_date: Thời gian kết thúc bỏ phiếu.\n\n**Ballot**\n\nPhiếu bầu dùng để lưu trữ thông tin bỏ phiếu của từng người tham gia hệ thống. Lá phiếu sẽ dùng để xác thực việc hoàn trả token sau này.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-4.3e0b193bdad8878523f4.png\">\n</p>\n\n*Hình 4: Thông tin phiếu bầu (Ballot schema)*\n\n## **Khai báo Instructions**\n### **Hàm initialize_candidate:**\nĐây là hàm giúp khởi tạo ứng viên mới. Khi muốn tạo mới ứng viên cho việc bầu cử cần gọi hàm **initialize_candidate**. Ứng viên sẽ được tạo mới với các dữ liệu mặc định.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\n\npub struct InitializeCandidate<'info> {\n\n  #[account(mut)]\n\n  pub authority: Signer<'info>,\n\n  #[account(\n\n    init,\n\n    payer = authority,\n\n    space = Candidate::SIZE,\n\n  )]\n\n  pub candidate: Account<'info, Candidate>,\n  \f\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n\n  CHECK: Just a pure account\n\n  pub treasurer: AccountInfo<'info>,\n\n  pub mint: Box<Account<'info, token::Mint>>, #[account(\n\n    init,\n\n    payer = authority,\n\n    associated_token::mint = mint, associated_token::authority = treasurer\n  )]\n\n  pub candidate_token_account: Account<'info, token::TokenAccount>, // System Program Address\n\n  pub system_program: Program<'info, System>,\n\n  pub token_program: Program<'info, token::Token>,\n\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n\n  pub rent: Sysvar<'info, Rent>,\n\n}\n```\n* **authority**: Địa chỉ ví thực hiện và trả phí giao dịch\n* **candidate**: Địa chỉ ứng viên. Mỗi ứng viên khác nhau có địa chỉ candidate khác nhau.\n* **treasurer**: Địa chỉ PDA quản lý candidate token account. Được tạo thành với seeds là “treasurer” và địa chỉ của candidate. Vậy nên candidate khác nhau có treasurer khác nhau.\n* Đối với những loại account không có kiểu dữ liệu cụ thể, cần thêm: /// CHECK:\n  Just a pure account\n* **mint**: Loại token được dùng để bỏ phiếu\n* **candidate_token_account**: Địa chỉ Token Account dùng để khoá tạm thời token để ngăn tấn công Double Spend.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<InitializeCandidate>, start_date: i64, end_date: i64) -> Result<()>\n{\n\n  let candidate = &mut ctx.accounts.candidate;\n\n  candidate.start_date = start_date;\n\n  candidate.end_date = end_date;\n\n  candidate.amount = 0;\n\n  candidate.mint = ctx.accounts.mint.key();\n  \f\n  Ok(())\n\n}\n```\n\nKhi hàm thực thi initialize_candidate được gọi, chương trình sẽ khởi tạo một Candidate mới với:\n\n*  start_date và end_date được truyền ở thông số đầu vào.\n*  Giá trị amount ban đầu bằng 0.\n*  Loại token dùng để bầu được định nghĩa trong Context.\n### **Hàm vote**\nĐây là hàm bầu cử cho ứng viên được lựa chọn. Sau khi gọi hàm vote, ứng viên được bầu sẽ tăng số lượng phiếu bầu tương ứng với số token chỉ định. Token dùng để bầu sẽ được khoá tạm thời nhằm ngăn chặn Double Spend.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\npub struct Vote<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n)]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  #[account(\n    init_if_needed,\n    payer = authority,\n    space = Ballot::SIZE,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n)]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*   ballot: Địa chỉ phiếu bầu của người đi bầu và cũng là một PDA. Lần đầu bầu, phiếu bầu này sẽ được tạo mới. Những lần bầu tiếp theo chỉ cần cập nhật dữ liệu trên địa chỉ đã tạo.\n*   voter_token_account: Địa chỉ ví của cử tri chứa loại token dùng để bầu cử (tương ứng với mint trong thông tin ứng viên).\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Vote>, amount: u64) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.start_date || now > candidate.end_date {\n    return err!(ErrorCode::NotActiveCandidate);\n  }\n  let transfer_ctx = CpiContext::new(\n    ctx.accounts.token_program.to_account_info(),\n    token::Transfer {\n      from: ctx.accounts.voter_token_account.to_account_info(),\n      to: ctx.accounts.candidate_token_account.to_account_info(),\n      authority: ctx.accounts.authority.to_account_info(),\n  }, );\n  token::transfer(transfer_ctx, amount)?;\n  candidate.amount += amount;\n  ballot.authority = ctx.accounts.authority.key();\n  ballot.candidate = candidate.key();\n  ballot.amount += amount;\n  Ok(())\n}\n```\n\nKhi hàm thực thi hàm Vote được gọi, chương trình sẽ khởi tạo một Ballot mới nếu cần thiết. Sau đó kiểm tra xem còn trong thời hạn được phép bầu hay không. Nếu chưa đến hoặc quá thời gian bầu thì báo lỗi, còn không sẽ thực hiện bầu cho ứng viên. Chuyển số token tương ứng với số lượng bầu cho ứng viên vào kho chứa token của Candidate để khoá tạm thời. Sau đó cập nhật lại số lượng bầu cho ứng viên và phiếu bầu.\n\n### **Hàm close:**\nĐây là hàm để lấy lại token đã bầu sau khi thời gian bầu cử kết thúc. Nếu thời gian bầu cử chưa kết thúc không cho phép close. Token đã dùng để bầu cử sẽ được hoàn trả cho cử tri và xoá bỏ phiếu bầu.\n\n*Khai báo context*\n\n```ts\n#[derive(Accounts)]\n  pub struct Close<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\", &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n  )]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  // Wallet accounts\n  #[account(\n    mut,\n    close = authority,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n  )]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*  ballot, voter_token_account: có ý nghĩa tương tự hàm vote. Tuy nhiên Ballot sẽ được thu hồi sau khi thực hiện hàm close.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Close>) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.end_date {\n  return err!(ErrorCode::EndedCandidate);\n}\n\nlet seeds: &[&[&[u8]]] = &[&[\n  \"treasurer\".as_ref(),\n  &candidate.key().to_bytes(),\n  &[*ctx.bumps.get(\"treasurer\").unwrap()],\n]];\n\nlet transfer_ctx = CpiContext::new_with_signer(\n  ctx.accounts.token_program.to_account_info(),\n  token::Transfer {\n    from: ctx.accounts.candidate_token_account.to_account_info(),\n    to: ctx.accounts.voter_token_account.to_account_info(),\n    authority: ctx.accounts.authority.to_account_info(),\n  },\n  seeds,\n);\n\ntoken::transfer(transfer_ctx, ballot.amount)?;\nballot.amount = 0;\nOk(()) }\n```\n\nKhi hàm thực thi close được gọi, chương trình sẽ kiểm tra xem đã hết thời hạn bầu hay chưa.\n* Nếu chưa thì báo lỗi.\n* Nếu đã hết thời hạn bầu, hệ thống sẽ hoàn trả số token tương ứng với số lượng đã bầu. Sau đó thu hồi lại phiếu bầu.\n## **References**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp:[ https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev]( https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)",
    "title": "Xây dựng Solana DApp đầu tiên (P1)"
  },
  "vn": {
    "title": "",
    "contents": ""
  }
}