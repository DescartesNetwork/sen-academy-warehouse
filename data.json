{
  "130904400097": {
    "createdAt": 1651633200923,
    "updatedAt": 1651636024778,
    "thumbnail": "",
    "category": [],
    "en": {
      "contents": "",
      "title": ""
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "216015801797": {
    "createdAt": 1652341125630,
    "updatedAt": 1652342838566,
    "thumbnail": "https://academy.sentre.io/static/media/fsp-thumbnail.2f16d88302c722808aa9.png",
    "category": [
      "dev",
      "blockchain",
      "solana"
    ],
    "en": {
      "contents": "Đối với lập trình viên, quá trình đi từ ý tưởng đến sản phẩm thực tiễn là một con đường gian nan với vô số rào cản, trong đó phần lập trình thô gây nhàm chán nhất.\n\nAnchor ra đời với các bản soạn sẵn phong phú và cơ số bước kiểm tra bảo mật, giúp developer rút ngắn thời gian lập trình thô và tập trung vào công đoạn quan trọng nhất - phát triển sản phẩm của chính mình.\n\n\n## **Tìm hiểu về Anchor**\n### **Anchor là gì?**\nAnchor(1) là một framework giúp các developer phát triển Smart Contract trên Solana nhanh chóng, dễ dàng và an toàn hơn.\n\nAnchor có cách đặc điểm sau:\n\n* Sử dụng ngôn ngữ Rust(2)\n* IDL để chỉ rõ cách hoạt động, sử dụng chương trình\n* Tự động tạo TypeScript Package từ IDL\n* Hỗ trợ nhiều câu lệnh, CLI ngắn gọn dễ dùng\n### **Cài đặt môi trường**\nTìm hiểu thêm thông tin tại (3).\n\n**Bước 1. Cài đặt Rust**\n\n```ts\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\nrustup component add rustfmt\n```\n\n**Bước 2. Cài đặt Solana**\n```ts\nsh -c \"$(curl -sSfL https://release.solana.com/v1.9.1/install)\"\n```\n\n**Bước 3. Cài đặt Yarn**\n\n```ts\nnpm install -g yarn\n```\n\n**Bước 4. Cài đặt Anchor**\n\n```ts\nnpm i -g @project-serum/anchor-cli\n```\n\nTạo ứng dụng đầu tiên\n\nĐể khởi tạo một project mới, bạn hãy chạy lệnh sau:\n\n```ts\nanchor init my_program\ncd my_program\n```\n        \nTrong đó **my_app** là tên project của bạn.\n\nSau khi tạo thành công, cấu trúc project sẽ như sau:\n\n* **programs/my_program/src/lib.rs**: Nơi định nghĩa, lập trình Smart Contract\n* **programs/my_program/Cargo.toml**: Nơi cài đặt các thư viện sử dụng\n* **target**: Nơi chứa dữ liệu sau khi build. Bao gồm IDL\n* **test**: Viết test cho Smart Contract\n<br/>\n![](https://lh4.googleusercontent.com/d5WchPxQgZgavXRJnc01rXXDuxK7j9s3kL-XIWbXfOfn57mtwrV9Z_uWn7X3j5MVYXeCvhjlBRr1GvzD5CzZmxbobcAuSYhYUr2bZ544-QCJtOFMgqan2TlLlgukgB1V1cjWWXiR)\n\n<br/>\n\nChạy test chương trình bằng dòng lệnh:\n\n```ts \nanchor test\n```\nHệ thống sẽ tự động thực thi các bước sau và cho ra kết quả:\n\n* Build smart contract từ file src/lib.rs\n* Tự động Deploy localhost\n* Ghi kết quả vào thư mục target\n* Chạy file test/my_program.ts → phân tích cấu trúc Smart Contract được build từ target/idl/my_program.json → tạo data phù hợp gọi lên Program đã được tự động deploy ở bước 2\n* Trả về kết quả\nKhi chạy **anchor test**, hệ thống đã tự build giúp mình. Nếu muốn build thủ công, bạn có thể dùng câu lệnh: anchor build\n\nSau khi build IDL được tạo ra ở thư mục **target/idl/my_program.json**\n\nMột instruction cũng giống như một hàm thông thường, bao gồm ba thông tin quan trọng là:\n\n* name: Tên hàm, dùng programe.rpc để gọi\n* accounts: Danh sách tài khoản sẽ tương tác\n* arg: tham số truyền vào hàm\n\n\nĐể hiểu rõ hơn, chúng ta sẽ cùng thực hành một ví dụ: Viết một chương trình tính tổng bao gồm:\n\n\n\n| Tên hàm | Logic thực thi | Tham số | Accounts |\n| -------- | -------- | -------- | ------- |\n| InitializeSum   | Thuê tài khoản để lưu kết quả tính tổng   | sum_init: Giá trị ban đầu của tổng| sumAccount: địa chỉ lưu kết quả tính tổng<br/>user: Người trả phí thuê tài khoản <br/>systemProgram: địa chỉ chương trình giúp thuê tài khoản|\n| updateSum | Cập nhật mới tổng | number:  giá trị cộng thêm vào | sumAccount: địa chỉ lưu kết quả tính tổng |\n\n<br/>\n\nMột hàm như vậy còn được gọi là instruction. Để viết và sử dụng một instruction, chúng ta cần đi qua các bước sau:\n\n* Khai báo cấu trúc dữ liệu cho trường hợp tạo mới\n* Khai báo các tài khoản tương tác\n* Khai bao instruction trong main\n### **Bước 1. Khởi tạo**\n1. Khai báo cấu trúc dữ liệu\n\n```ts\n#[account]\npub struct SumAccount {\n  pub sum: u64,\n}\n```\n\n2. Khai báo các tài khoản sẽ tương tác\n\n```ts\n#[derive(Accounts)]\npub struct Initialize<'info> {\n   // địa chỉ thuê\n  #[account(init, payer = user, space = 8 + 8)]\n  pub my_account: Account<'info, MyAccount>,\n\n  // người trả phí giao dịch\n   #[account(mut)]\n  pub user: Signer<'info>,\n\n  // địa chỉ chương trình giúp thuê tài khoản\n   pub system_program: Program<'info, System>,\n}\n```\n\n3. Khai báo hàm thực thi\n\n```ts\npub fn initialize(ctx: Context<Initialize>, sum_init: u64) -> Result<()> {\n  let my_account = &mut ctx.accounts.my_account;\n  my_account.sum = sum_init;\n  Ok(())\n}\n```\n<br/>\n\nChương trình của chúng ta sẽ trông như thế này:\n\n```ts\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod my_program {\n  use super::*;\n  pub fn initialize_sum(ctx: Context<InitializeSum>, sum_init: u64) -> Result<()> {\n    ctx.accounts.sum_account.sum = sum_init;\n    Ok(())\n  }\n}\n\n#[derive(Accounts)]\n  pub struct InitializeSum<'info> {\n  #[account(init, payer = user, space = 8 + 8)]\n  pub sum_account: Account<'info, SumAccount>,\n  #[account(mut)]\n  pub user: Signer<'info>,\n  pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct SumAccount {\n  pub sum: u64,\n}\n```\n\n4. Chạy anchor build để chương trình tạo IDL\n\n```ts\n\"instructions\": [\n  {\n    \"name\": \"initializeSum\",\n    \"accounts\": [\n      {\n        \"name\": \"sumAccount\",\n        \"isMut\": true,\n        \"isSigner\": true\n      },\n      {\n        \"name\": \"user\",\n        \"isMut\": true,\n        \"isSigner\": true\n      },\n      {\n        \"name\": \"systemProgram\",\n        \"isMut\": false,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": [\n      {\n        \"name\": \"sumInit\",\n        \"type\": \"u64\"\n      }\n    ]\n  }\n],\n```\n\nDựa vào IDL, chúng ta biết được cách sử dụng hàm này từ client bằng typescript. Cập nhật file test như sau:\n\n```ts\nimport { Program, setProvider, web3, Provider, workspace, BN } from \"@project-serum/anchor\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport { MyProgram } from \"../target/types/my_program\";\n\ndescribe(\"my_program\", () => {\n  setProvider(Provider.env());\n  const program = workspace.MyProgram as Program<MyProgram>;\n\n  // Tạo địa chỉ thuê\n  const sumAccount = web3.Keypair.generate();\n  it(\"Is initialized!\", async () => {\n    await program.rpc.initializeSum(new BN(1), {\n      accounts: {\n        sumAccount: sumAccount.publicKey,\n        user: program.provider.wallet.publicKey,\n        systemProgram: SystemProgram.programId,\n      },\n      signers: [sumAccount],\n    });\n\n    let sumAccountData = await program.account.sumAccount.fetch(sumAccount.publicKey);\n    console.log(\"sumAccountData\", sumAccountData.sum);\n  }\n);\n```\n\n<br/>\n\nChạy anchor test cho ra kết quả:\n\n![](https://lh5.googleusercontent.com/pb6D0IIKmMDPdg4tth8B6ijlQXAShQj0-R-GdInGHc4PBe3inniwwurJKt-BrdJfoaqFJ832k3IaVw_0kp_0iLBo9eOcJRNB9x49HNEPpfl83qqaPonYlwxs0i1nb3MRZMMgTtEN)\n\n\nVậy là chúng ta đã thuê thành công một tài khoản để chứa dữ liệu tính tổng.\n\n\n### **Bước 2. Cập nhật dữ liệu**\nLúc này, account chứa dữ liệu đã được tạo nên không cần khai báo cấu trúc SumAccount nữa. Cập nhật các tài khoản tương tác và khai báo instruction:\n\n```ts\n#[derive(Accounts)]\npub struct UpdateSum<'info> {\n  #[account(mut)]\n  pub sum_account: Account<'info, SumAccount>,\n}\n```\n<br/>\n\n```ts\npub fn update_sum(ctx: Context<UpdateSum>, number: u64) -> Result<()> {\n  ctx.accounts.sum_account.sum += number;\n  Ok(())\n}\n```\n<br/>\n\nChương trình sẽ trông như thế này:\n\n```ts\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod my_program {\n  use super::*;\n  pub fn initialize_sum(ctx: Context<InitializeSum>, sum_init: u64) -> Result<()> {\n    ctx.accounts.sum_account.sum = sum_init;\n    Ok(())\n  }\n\npub fn update_sum(ctx: Context<UpdateSum>, number: u64) -> Result<()> {\n  ctx.accounts.sum_account.sum += number;\n  Ok(())\n  }\n}\n\n#[derive(Accounts)]\npub struct InitializeSum<'info> {\n   #[account(init, payer = user, space = 8 + 8)]\n  pub sum_account: Account<'info, SumAccount>,\n  #[account(mut)]\n  pub user: Signer<'info>,\n  pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct UpdateSum<'info> {\n  #[account(mut)]\n  pub sum_account: Account<'info, SumAccount>,\n}\n\n#[account]\npub struct SumAccount {\n  pub sum: u64,\n}\n```\n<br/>\n\nGọi từ client:\n\n```ts\nit(\"Update sum!\", async () => {\n  await program.rpc.updateSum(new BN(2), {\n    accounts: {\n      sumAccount: sumAccount.publicKey,\n    },\n  });\n\n  let sumAccountData = await program.account.sumAccount.fetch(sumAccount.publicKey);\n  console.log(\"sumAccountData\", sumAccountData.sum);\n});\n```\n\nChạy anchor test và cho ra kết quả:\n\nSum đã được cập nhật từ 1 lên 3.\n\nVậy là chúng ta vừa đi qua 2 ví dụ cơ bản của lập trình trên blockchain. Hãy xem video để thực hành và bình luận nếu có thắc mắc nhé!\n\n\n# **Các tài liệu tham khảo**\n1. https://project-serum.github.io/anchor/getting-started/introduction.html\n2. https://doc.rust-lang.org/book/\n3. https://project-serum.github.io/anchor/getting-started/installation.html",
      "title": "Viết phần mềm Solana đầu tiên"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353825179923": {
    "createdAt": 1652327506346,
    "updatedAt": 1652328751944,
    "thumbnail": "https://academy.sentre.io/static/media/ds2-thumbnail.37b81891d1e8e3a58281.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong [Workshop 1](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev), chúng ta đã hoàn thành Solana program cho hệ thống bỏ phiếu có trọng số. Trong bài này, chúng ta sẽ cùng nhau phát triển giao diện đơn giản cũng như kết nối giao diện đó với Solana program để thực hiện việc giao tiếp cho hệ thống.\n\n\n## **Building the React App**\nTrong thư mục gốc của dự án Anchor, tạo một React app mới để ghi đè lên thư mục app hiện có:\n\n```ts\nnpx create-react-app app --template typescript\ncd app\n```\n\nTham khảo [bài số 2](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev) và [bài số 3](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev) để cài đặt ứng dụng cũng như các dependencies.\n\n\n### **Kết nối đến ví**\nỞ các bài trước, chúng ta đã tìm hiểu về Goki, cách kết nối ví và lưu thông tin ví vào Redux để có thể sử dụng, quản lý một cách hiệu quả. Tương tự như vậy, chúng ta ứng dụng lại vào chương trình và tạo kết nối đến ví người dùng.\n\n```ts\n// view/app/index.tsx\nimport { useCallback, useEffect } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { useWalletKit, useSolana, useConnectedWallet } from '@gokiprotocol/walletkit'\n\nimport { Button, Col, Layout, Row, Typography } from 'antd'\nimport ListCandidates from 'view/listCandidates'\nimport CandidateCreate from 'view/candidateCreate'\n\nimport { setWalletInfo, WalletState } from 'store/wallet.reducer'\nimport { AppDispatch } from 'store'\n\nconst { Header, Content } = Layout\n\nfunction App() {\n  const dispatch = useDispatch<AppDispatch>()\n  const wallet = useConnectedWallet()\n  const { connect } = useWalletKit()\n  const { providerMut } = useSolana()\n\n  const fetchWalletInfo = useCallback(async () => {\n    if (!wallet || !providerMut) return\n    // TODO: fetch SOL balance\n    const lamports = await providerMut.connection.getBalance(wallet.publicKey)\n    let walletInfo: WalletState = {\n      walletAddress: wallet.publicKey.toBase58(),\n      balance: lamports,\n    }\n    dispatch(setWalletInfo(walletInfo))\n  }, [providerMut, wallet])\n\n  useEffect(() => {\n    fetchWalletInfo()\n  }, [fetchWalletInfo])\n\n  return (\n    <Layout style={{ height: '100vh' }}>\n      <Header>\n        <Col span={24}>\n          {wallet ? (\n            <Col span={24} style={{ color: 'white' }}>\n              {wallet.publicKey.toBase58()}\n            </Col>\n          ) : (\n            <Button type=\"primary\" style={{ borderRadius: 40 }} onClick={connect}>\n              Connect Wallet\n            </Button>\n          )}\n        </Col>\n      </Header>\n      <Content style={{ padding: 40 }}>\n        <Row gutter={[24, 24]}>\n          <Col span={24}>\n            <Row gutter={[24, 24]}>\n              <Col flex=\"auto\">\n                <Typography.Title>List Candidates</Typography.Title>\n              </Col>\n              <Col>\n                <CandidateCreate />\n              </Col>\n            </Row>\n          </Col>\n          <Col span={24}>\n            <ListCandidates />\n          </Col>\n        </Row>\n      </Content>\n    </Layout>\n  )\n}\n\nexport default App\n```\n\n### **Giao diện bỏ phiếu**\n\n#### **Danh sách Candidate**\nGiao diện List candidates thể hiện cách thông tin: **candidate, start_date, end_date, …**\n\n\n![](https://academy.sentre.io/static/media/post-6-h1.a72f76ebb18473abedef.png)\n*Hình 1. Danh sách các ứng viên vào thông tin bỏ phiếu.*\n\n#### **Hàm khởi tạo ứng viên (New candidate)**\nGiao diện khởi tạo candidate cần các thông tin cơ bản như địa chỉ token để bỏ phiếu, ngày bắt đầu, ngày kết thúc bỏ phiếu.\n\n\n![](https://academy.sentre.io/static/media/post-6-h2.ba78517cd8d683ad0e10.png)\n*Hình 2. Giao diện khởi tạo thông tin cho ứng viên.*\n\n#### **Hàm bỏ phiếu (Vote)**\n\n\n![](https://academy.sentre.io/static/media/post-6-h3.1e5b88f42343e518990e.png)\n*Hình 3. Cử tri nhập số lượng tokens để bầu cho ứng viên.*\n\n### **Kết nối đến Solana Program (Smart Contract)**\n\nSao chép tệp **target/types/l6.ts** vào thư mục **app/config** và đặt tên **idl.ts**. Tệp này giúp định nghĩa các giao diện (interface) của Solana program. Nó giúp các chương trình off-chain, có thể là frontend hoặc backend với các ngôn ngữ khác nhau, biết các để giao tiếp với chương trình chạy on-chain. Nếu các bạn đã quen thuộc với Ethereum thì tệp IDL này có ý nghĩa tương đương với ABI.\n\nTiếp đến chúng ta phải tạo file config để định nghĩa kết nối. Cụ thể là mạng **devnet**.\n\n```ts\n// app/src/config/index.ts\nimport * as anchor from '@project-serum/anchor'\nimport { clusterApiUrl } from '@solana/web3.js'\n\nimport { IDL } from './idl'\n\nexport const DEFAULT_COMMITMENT = 'confirmed'\nexport const DEFAULT_CLUSTER = 'devnet'\nexport const PROGRAM_ADDRESS = new anchor.web3.PublicKey(\n  'HCoUastFpW7wB9Ue4o4YHy27VTuiJEo7h9hKmhnXDQhD',\n)\nexport const NODE_URL = clusterApiUrl(DEFAULT_CLUSTER)\n\nexport type CandidateData = {\n  address: string\n  mint: string\n  amount: number\n  startTime: number\n  endTime: number\n}\n\n// Function support\nexport const getProvider = (wallet: any) => {\n  const connection = new anchor.web3.Connection(NODE_URL, DEFAULT_COMMITMENT)\n  return new anchor.Provider(connection, wallet, {\n    preflightCommitment: DEFAULT_COMMITMENT,\n  })\n}\n\nexport const getProgram = (wallet: any) => {\n  const provider = getProvider(wallet)\n  return new anchor.Program(IDL, PROGRAM_ADDRESS, provider)\n}\n```\n\n\nViết hàm gọi và truyền vào các tham số định nghĩa ở IDL để tạo ứng viên\n\n```ts\nawait program.rpc.initializeCandidate(new anchor.BN(startTime), new anchor.BN(endTime), {\n  accounts: {\n    authority: wallet.publicKey,\n    candidate: candidate.publicKey,\n    treasurer,\n    mint: new anchor.web3.PublicKey(mintAddress),\n    candidateTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [candidate],\n})\n```\n\nTạo hàm bỏ phiếu cho ứng viên\n\n```ts\nawait program.rpc.vote(new anchor.BN(amount), {\n    accounts: {\n    authority: wallet.publicKey,\n    candidate: candidatePublicKey,\n    treasurer,\n    mint: candidateData.mint,\n    candidateTokenAccount,\n    ballot,\n    voterTokenAccount: walletTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [],\n  })\n```\n\nTạo hàm close vote\n\n```ts\nawait program.rpc.close({\naccounts: {\n  authority: wallet.publicKey,\n  candidate: candidatePublicKey,\n  treasurer,\n  mint: candidateData.mint,\n  candidateTokenAccount,\n  ballot,\n  voterTokenAccount: walletTokenAccount,\n  tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n  associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n  systemProgram: anchor.web3.SystemProgram.programId,\n  rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n},\nsigners: [],\n})\n```\n\n## **Tham khảo**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp: [https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)\n\nPDA và chuẩn SPLT trong lập trình Solana: [https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev](https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev)\n\nXây dựng DApp đầu tiên trên Solana (phần 1): [https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev)",
      "title": "Xây dựng Solana DApp đầu tiên (P2)"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353917979844": {
    "createdAt": 1651640470205,
    "updatedAt": 1651822151703,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [
      "user"
    ],
    "en": {
      "contents": "\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nSome useful information that you can also consider as below:\n-  ....",
      "title": "8th Post"
    },
    "vn": {
      "contents": "Tiếng việt phiên bản\n\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nCác thông tin hữu ích như dưới đây:\n-  ....",
      "title": "Bài viết số 8"
    }
  },
  "376381180886": {
    "createdAt": 1652339540727,
    "updatedAt": 1652341098108,
    "thumbnail": "https://academy.sentre.io/static/media/pss-thumbnail.eab33090c0f4b6b621c8.png",
    "category": [
      "dev",
      "blockchain",
      "solana"
    ],
    "en": {
      "contents": "Khi tạo dựng một DApp trên Solana, bạn sẽ cần tạo SPL token tương ứng cũng như cài đặt một tài khoản/địa chỉ do chương trình quản lý (Program Derived Account/Address - PDA) nhằm tránh rủi ro cho nguồn thanh khoản của DApp. Bài viết này sẽ giúp các bạn hiểu rõ hơn về chuẩn SPLT khi tạo token, cách PDA hoạt động, cách thuê tài khoản, tạo PDA và cập nhật dữ liệu trên đó.\n\n## **SPLT Program là gì?**\n**SPL Token là fungible token**\n\n(token có thể thay thế được) trên mạng lưới blockchain Solana. Các token này được tạo ra dựa trên Solana Program Library (SPL) và được lưu trong các ví tương thích với Solana, ví dụ như ví Phantom chứa SOL, SNTR, vân vân.\n\nFungible token là một tập hợp các token chứa tất cả các thuộc tính giống hệt nhau và có thể trao đổi cho nhau. Chúng có thể phân chia được và không phải là duy nhất. Ví dụ như đồng đô la chẳng hạn: Tờ 1 đô la ở New York có giá trị tương đương với tờ 1 đô la ở Việt Nam. Một fungible token cũng có thể là một loại tiền điện tử như SOL: 1 SOL có giá trị bằng 1 SOL, bất kể nó được phát hành ở đâu.\n\n**SPL (Solana Program Library)**\n\nlà tập hợp các chương trình Solana mà đội ngũ lập trình viên Solana đã triển khai trên blockchain. SPL cũng là tiêu chuẩn kỹ thuật được sử dụng cho các Smart Contract trên mạng lưới Solana, bao gồm cả SPL Token Program.\n\nSPL Token Program được sử dụng để tạo và quản lý SPL Token bằng cách sử dụng Token Program. Điều này giúp dev đơn giản hóa việc quản lý các token, bởi tất cả những gì bạn cần làm chỉ là gửi lệnh hướng dẫn đến Token Program để mint/transfer/burn tokens.\n\n## **PDA (Program Derived Address/Account) là gì?**\nProgram Derived Address (PDA) cho phép các chương trình điều khiển một số địa chỉ nhất định và đảm bảo không một người dùng bên ngoài nào có thể tạo các giao dịch hợp lệ có chữ ký với các địa chỉ đó. Có thể hiểu rằng với PDA, các chương trình có thể ký cho các địa chỉ nhất định này mà không cần private key.\n\nKhi sử dụng một PDA, một chương trình có thể được cấp quyền cho một tài khoản và sau đó chuyển quyền này cho một tài khoản khác. Điều này khả thi vì chương trình có thể đóng vai trò là “người ký” trong giao dịch cung cấp quyền hạn.\n\nChúng ta cùng làm rõ định nghĩa trên nhé:\n\n* Ở Solana, các chương trình là stateless: Bất kỳ dữ liệu nào chúng ta cần làm việc phải được chuyển vào bằng cách tham chiếu từ bên ngoài (giống như máy tính đục lỗ) và thuê account (thuê vùng nhớ giống như đưa vào tấm bìa đục lỗ) để lưu trữ các dữ liệu.\n* Account là một nơi chứa dữ liệu (ví dụ: số token bạn đang giữ) - khi đó được gọi là “data account”, hoặc là một chương trình thực thi (ví dụ: một smart contract) - khi đó được gọi là “program account\". Tất cả trạng thái sẽ được lưu trong data account. Mỗi account là một địa chỉ duy nhất và địa chỉ đó là khóa công khai (Public Key) của một cặp khóa (Keypair) được sở hữu bởi một chương trình. Chỉ chủ sở hữu tài khoản mới có thể sửa đổi nó.\n* Khi bạn có một token thuê account như trên và đưa cho contract, nó sẽ ghi vào vị trí tương ứng và token đó sẽ thuộc quyền sở hữu của bạn. Chương trình PDA có thể giúp bạn thực hiện việc đó. Chương trình PDA không chứa Private Key, bởi nếu user nào nắm giữ Private Key này sẽ có toàn quyền sửa đổi data của account.\n* Ví dụ 1: User chỉ sở hữu 10 đồng, nhưng lại có thể tự update thành 100, 1000…\n* Ví dụ 2: Vào một ngày đẹp trời, công ty của bạn muốn biểu quyết xem nên mua pizza hay hamburger cho buổi tiệc sắp tới. Bạn cần tạo chương trình để mọi người có thể tham gia bỏ phiếu. Muốn bỏ phiếu chọn pizza hay hamburger thì cần cập nhật dữ liệu số lượng phiếu, và cần Private Key để lưu thông tin bỏ phiếu. Như vậy, chỉ người tạo ra account đó mới cập nhật được số lượng vote, và nếu công ty lưu Private Key ở đâu đó thì người có thông tin này sẽ có thể thay đổi tùy ý số phiếu bầu, như ví dụ trên. PDA sẽ giúp loại bỏ rủi ro trong trường hợp này.\n## **Cơ chế hoạt động của PDA**\nProgram address được xác định từ một tập hợp các seeds và program ID bằng cách sử dụng hàm băm SHA-256.\n\nProgram address không được nằm trên đường cong ed25519 để đảm bảo không có khoá cá nhân nào liên quan. Trong quá trình tạo, nếu địa chỉ được tìm thấy nằm trên đường cong, chương trình sẽ báo lỗi. Có khoảng 50% khả năng xảy ra lỗi này đối với một tập hợp seeds và program ID nhất định.\n\nNếu điều này xảy ra, có thể dùng một tập hợp khác của seeds hoặc seed bump (seed 8 bit bổ sung) để tìm programs address hợp lệ ngoài đường cong.\n\nVì không có khóa riêng được liên kết, người dùng bên ngoài không thể tạo chữ ký hợp lệ cho PDA.\n\nsolana\n\n![](https://lh3.googleusercontent.com/LC-KSgoBprEUveCqmQnx8nhyVZBo4d2GkC9R6U7CTXgXXrjNUli7eajRWa7bY4hdG3EhMW569AT760wnFZxGRA4WJAsKG42s98AfMKCUFHSzw3d3ncdNSvb4duOGQvcazilvQU16)\n\n\n## **Viết chương trình demo**\nGiờ chúng ta cùng thử tạo chương trình vote ăn pizza hay hamburger nhé!\n\n### **Bước 1. Tạo project**\n```ts\nanchor init demo_spl\ncd demo_spl\n```\n\n### **Bước 2. Định nghĩa cấu trúc dữ liệu**\n* Chúng ta xác định trạng thái của “vote_account” trông như thế nào.\n* VotingState là một cấu trúc có ba thuộc tính: pizza, hamburger và bump.\n* Thuộc tính “pizza” và “hamburger” sẽ theo dõi các phiếu vote tương ứng của chúng dưới dạng số nguyên dương 64-bit.\n* “bump” sẽ lưu trữ “vote_account_bump” mà chúng ta sẽ truyền vào khi khởi chạy chương trình của mình.\n* “bump” này kết hợp với “seed” tĩnh sẽ giúp mọi người dễ dàng lấy được cùng một PDA sử dụng để theo dõi trạng thái của chúng ta.\n\n\nFolder: *demospl/programs/demospl/src/lib.rs*\n\n```ts\n#[account]\npub struct VotingState {\n pub pizza: u64,n . pub hamburger: u64,\n pub bump: u8,n}\n```\n\n### **Bước 3. Khai báo các tài khoản tương tác**\n#[derive(Accounts)] chỉ định tất cả các tài khoản được yêu cầu cho một instruction nhất định. Ở đây, chúng ta xác định hai cấu trúc: Initialize và Vote.\n\n```ts\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, seeds = [b\"seed\".as_ref()], bump, payer = user, space = 8 + 16 + 1)]\n    pub vote_account: Account<'info, VotingState>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut, seeds = [b\"seed\".as_ref()], bump = vote_account.bump)]\n    vote_account: Account<'info, VotingState>,\n}\n```\n\n### **Bước 4. Khai báo các hàm thực thi**\n```ts\npub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {\n    ctx.accounts.vote_account.bump = vote_account_bump;\n    Ok(())\n}\n\npub fn vote_pizza(ctx: Context<Vote>) -> Result<()> {\n    ctx.accounts.vote_account.pizza += 1;\n    Ok(())\n}\n\npub fn vote_hamburger(ctx: Context<Vote>) -> Result<()> {\n    ctx.accounts.vote_account.hamburger += 1;\n    Ok(())\n}\n```\n   \n\nChương trình của chúng ta sẽ trông như sau:\n\n```ts\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod demo_spl {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {\n        ctx.accounts.vote_account.bump = vote_account_bump;\n        Ok(())\n    }\n\n    pub fn vote_pizza(ctx: Context<Vote>) -> Result<()> {\n        ctx.accounts.vote_account.pizza += 1;\n        Ok(())\n    }\n\n    pub fn vote_hamburger(ctx: Context<Vote>) -> Result<()> {\n        ctx.accounts.vote_account.hamburger += 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, seeds = [b\"seed\".as_ref()], bump, payer = user, space = 8 + 16 + 1)]\n    pub vote_account: Account<'info, VotingState>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut, seeds = [b\"seed\".as_ref()], bump = vote_account.bump)]\n    vote_account: Account<'info, VotingState>,\n}\n\n#[account]\npub struct VotingState {\n    pub pizza: u64,\n    pub hamburger: u64,\n    pub bump: u8,\n}\n```\n### **Bước 4. Khai báo các hàm thực thi**\n```ts\nanchor build\n```\n\nIDL:\n\n* Thông tin chương trình có thể xem trong /target/idl/demo_spl.json\n* Đây là nơi xác định chương trình của chúng ta.\n* Mỗi phương thức bên trong xác định một trình xử lý yêu cầu RPC và có thể được gọi bởi client.\n```ts\n{\n\"version\": \"0.1.0\",\n\"name\": \"demo_spl\",\n\"instructions\": [\n  {\n    \"name\": \"initialize\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      },\n      {\n        \"name\": \"user\",\n        \"isMut\": true,\n        \"isSigner\": true\n      },\n      {\n        \"name\": \"systemProgram\",\n        \"isMut\": false,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": [\n      {\n        \"name\": \"voteAccountBump\",\n        \"type\": \"u8\"\n      }\n    ]\n  },\n  {\n    \"name\": \"votePizza\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": []\n  },\n  {\n    \"name\": \"voteHamburger\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": []\n  }\n],\n\"accounts\": [\n  {\n    \"name\": \"VotingState\",\n    \"type\": {\n      \"kind\": \"struct\",\n      \"fields\": [\n        {\n          \"name\": \"pizza\",\n          \"type\": \"u64\"\n        },\n        {\n          \"name\": \"hamburger\",\n          \"type\": \"u64\"\n        },\n        {\n          \"name\": \"bump\",\n          \"type\": \"u8\"\n        }\n      ]\n    }\n  }\n]\n}\n```\n\nVới IDL chúng ta sẽ update lại test chương trình:\n\ndemo_spl.ts\n\n```ts\nimport * as anchor from \"@project-serum/anchor\";\nimport { Program } from \"@project-serum/anchor\";\nimport { DemoSpl } from \"../target/types/demo_spl\";\nconst { SystemProgram } = anchor.web3;\n\ndescribe(\"demo_spl\", async () => {\n  // Use a local provider.\n  const provider = anchor.Provider.local();\n\n  // Configure the client to use the local cluster.\n  anchor.setProvider(provider);\n\n  const program = anchor.workspace.DemoSpl as Program<DemoSpl>;\n\n\n  //Client muốn read/write account vote\n  //Bằng cách sử dụng findProgramAddress, bạn không cần phải lưu trữ Public key\n  //thay vào đó, bạn có thể dễ dàng tìm được một địa chỉ PDA nhờ vào seed, programId để thuê nó \n  //hoặc đọc và cập nhật dữ liệu\n  const [account, accountBump] = await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from(\"seed\")],\n    program.programId\n  );\n\n  it(\"Is initialized!\", async () => {\n    await program.rpc.initialize(new anchor.BN(accountBump), {\n      accounts: {\n        voteAccount: account,\n        user: provider.wallet.publicKey,\n        systemProgram: SystemProgram.programId\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.bump),\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n  it(\"Vote pizza!!!\", async () => {\n    await program.rpc.votePizza({\n      accounts: {\n        voteAccount: account\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n\n  it(\"Vote hamburger!!!\", async () => {\n    await program.rpc.voteHamburger({\n      accounts: {\n        voteAccount: account\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n});\n```\n\n### **Bước 6. Chạy anchor test và xem kết quả**\n```ts\nanchor test\n```\n<br />\n<p align=\"center\">\n  <img src=\"https://lh4.googleusercontent.com/y3DR7GxiOi25HXTJ9ROvTvoHekDgL8z010_vq70kV2Fm4T_tG5Q8KKrG_TZs5wkcbfkXprm4u9bKcxrfVjASKsV_-8POqlZqjsMxK5V-umvHTJrny6NewnOlpENGAHz1rMjCYXJ9\">\n</p>\n\n\nKhi khởi tạo “Is initialized!”, dữ liệu bump, vote cho pizza và hamburger lần lượt là 253 0 0.\n\nKhi vote pizza “Vote pizza!!!”, dữ liệu vote cho pizza tăng lên là 1 và hamburger là 0.\n\nKhi vote hamburger “Vote hamburger!!!”, dữ liệu vote cho pizza giữ nguyên là 1 và hamburger tăng lên là 1.\n\nVậy là các bạn đã hoàn thành việc tìm hiểu về PDA, cách thuê account, tạo PDA và update dữ liệu trên PDA. Hãy xem video hướng dẫn từng bước và để lại bình luận nếu có thắc mắc nhé!\n\n## **Tài liệu tham khảo**\n1. https://spl.solana.com/\n2. https://solanacookbook.com/core-concepts/pdas.html\n3. ​​https://solana.wiki/zh-cn/docs/account-model/#account-storage\n4. https://www.brianfriel.xyz/understanding-program-derived-addresses/",
      "title": "PDA và chuẩn SPLT trong lập trình Solana"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "423086673347": {
    "createdAt": 1652328797208,
    "updatedAt": 1652339528367,
    "thumbnail": "https://academy.sentre.io/static/media/ds-thumbnail.4bb629ac92820acea899.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Sau khi hoàn thành 5 bài đầu tiên trong chuỗi 10 bài, chúng ta đã được trang bị các kiến thức cơ bản nhất để xây dựng một DApp hoàn chỉnh. Để giúp bạn đọc có thể hệ thống lại kiến thức, bài viết xin nhắc lại các kiến thức đã học gồm:\n\n* ReactJS - giúp phát triển ứng dụng nền Web.\n* Ant Design - giúp xây dựng nhanh chóng giao diện người dùng bằng các thành phần dựng sẵn.\n* Redux Toolkit - giúp quản lý trạng thái của ứng dụng với số lượng dữ liệu và trạng thái phức tạp.\n* Anchor - giúp phát triển chương trình chạy được trên chuỗi khối. Solana dùng thuật ngữ program, hoặc Ethereum dùng thuật ngữ smart contract để ám chỉ chương trình này.\n\nTrong bài này chúng ta sẽ kết hợp tất cả chúng lại để xây dựng một ứng dụng bỏ phiếu một cách hoàn chỉnh nhất.\n\n## **Hệ thống bỏ phiếu điện tử có trọng số (Weighted eVoting System)**\nTrong phần này chúng ta sẽ đi phân tích xem để hiểu được hệ thống bỏ phiếu điện tử có trọng số (sau đây sẽ gọi ngắn gọn là hệ thống) có những đặc tính cơ bản nào.\n\n### **Phiếu bầu có trọng số**\nĐối với các hệ thống bỏ phiếu phổ biến, đa số chúng đều là không trọng số. Nghĩa là mọi người bỏ phiếu (voter) đều có “sức mạnh” như nhau và bằng chính xác 1 lá phiếu. Dù bạn rất nổi tiếng, hay bạn là một sinh viên, thì lá phiếu của bạn đều chỉ được tính là 1. Ngược lại, trong hệ thống có trọng số, yếu tố “sức mạnh” được xem xét đến trong quá trình kiểm phiếu. Cụ thể hơn,\n\ntrên môi trường blockchain, số lượng một token cụ thể bạn đang nắm sẽ đại diện cho sức mạnh lá phiếu của bạn.\n\n* hình 1, người bỏ phiếu có 10 tokens và anh ấy có thể dùng 10 tokens đó để đại diện cho “sức mạnh” lá phiếu bầu. Ví dụ, anh ấy bỏ phiếu cho Candidate #1, thì hệ thống sẽ ghi nhận Cadidate #1 được cộng thêm 10 điểm.\n\n\n![](https://academy.sentre.io/static/media/post-5-weight.46eaad4973b1f98b7529.png)\n### **Double Spend**\nDouble Spend hay “Dùng hai lần” là một hình thức gian lận giúp người dùng có thể sử dụng nhiều hơn một lần bằng 1 số lượng tokens cụ thể. Trong phạm vi hệ thống, sử dụng được hiểu theo nghĩa là bỏ phiếu. Giả sử như sau khi bỏ phiếu bằng ví số 1, người dùng cố tình chuyển số tokens ban đầu sang một ví số 2 nhằm thực hiện lại hành vi bỏ phiếu không hợp lệ. Tiếp tục như vậy, với chỉ 10 tokens, người dùng có thể bỏ phiếu vô số lần.\n\nĐể đảm bảo được tính công bằng, với mỗi lượt bỏ phiếu, số token của người dùng phải được khoá trong thời gian bỏ phiếu. Cơ chế khoá được hiện thực đơn giản bằng cách chuyển token người dùng vào một ví tạm thời và chỉ hệ thống mới có thể kiểm soát ví đó. Hết thời hạn bỏ phiếu, số token sẽ được trả lại chính xác cho người bỏ phiếu.\n\n \n\n![](https://academy.sentre.io/static/media/post-5-weight-2.8ba8bcc02fe2f5db029b.png)\n*Hình 2. Token người dùng sẽ được khoá tạm thời trong thời gian bỏ phiếu. Số token này sẽ đc hoàn trả khi kết thúc bỏ phiếu.*\n\n## **Hiện thực hệ thống**\n### **Khai báo Schema**\n#### **Candidate**\n\nMỗi ứng viên sẽ được tạo một tài khoản trên chuỗi khối nhằm ghi nhận số lượng người bỏ phiếu cũng như quản lý các thông tin cần thiết cho việc bỏ phiếu. Để cho đơn giản, ở đây bài viết lược bỏ đi khá nhiều thông tin và chỉ giữ lại các thông tin cơ bản nhất.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-3.43baaffb217762c92a1f.png\">\n</p>\n\n*Hình 3. Thông tin ứng viên (Candidate schema)*\n\n* mint: Loại token được dùng để bỏ phiếu.\n* amount: số lượng token bầu cho ứng viên.\n* start_date: Thời gian bắt đầu cho phép bỏ phiếu\n* end_date: Thời gian kết thúc bỏ phiếu.\n\n**Ballot**\n\nPhiếu bầu dùng để lưu trữ thông tin bỏ phiếu của từng người tham gia hệ thống. Lá phiếu sẽ dùng để xác thực việc hoàn trả token sau này.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-4.3e0b193bdad8878523f4.png\">\n</p>\n\n*Hình 4: Thông tin phiếu bầu (Ballot schema)*\n\n## **Khai báo Instructions**\n### **Hàm initialize_candidate:**\nĐây là hàm giúp khởi tạo ứng viên mới. Khi muốn tạo mới ứng viên cho việc bầu cử cần gọi hàm **initialize_candidate**. Ứng viên sẽ được tạo mới với các dữ liệu mặc định.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\n\npub struct InitializeCandidate<'info> {\n\n  #[account(mut)]\n\n  pub authority: Signer<'info>,\n\n  #[account(\n\n    init,\n\n    payer = authority,\n\n    space = Candidate::SIZE,\n\n  )]\n\n  pub candidate: Account<'info, Candidate>,\n  \f\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n\n  CHECK: Just a pure account\n\n  pub treasurer: AccountInfo<'info>,\n\n  pub mint: Box<Account<'info, token::Mint>>, #[account(\n\n    init,\n\n    payer = authority,\n\n    associated_token::mint = mint, associated_token::authority = treasurer\n  )]\n\n  pub candidate_token_account: Account<'info, token::TokenAccount>, // System Program Address\n\n  pub system_program: Program<'info, System>,\n\n  pub token_program: Program<'info, token::Token>,\n\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n\n  pub rent: Sysvar<'info, Rent>,\n\n}\n```\n* **authority**: Địa chỉ ví thực hiện và trả phí giao dịch\n* **candidate**: Địa chỉ ứng viên. Mỗi ứng viên khác nhau có địa chỉ candidate khác nhau.\n* **treasurer**: Địa chỉ PDA quản lý candidate token account. Được tạo thành với seeds là “treasurer” và địa chỉ của candidate. Vậy nên candidate khác nhau có treasurer khác nhau.\n* Đối với những loại account không có kiểu dữ liệu cụ thể, cần thêm: /// CHECK:\n  Just a pure account\n* **mint**: Loại token được dùng để bỏ phiếu\n* **candidate_token_account**: Địa chỉ Token Account dùng để khoá tạm thời token để ngăn tấn công Double Spend.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<InitializeCandidate>, start_date: i64, end_date: i64) -> Result<()>\n{\n\n  let candidate = &mut ctx.accounts.candidate;\n\n  candidate.start_date = start_date;\n\n  candidate.end_date = end_date;\n\n  candidate.amount = 0;\n\n  candidate.mint = ctx.accounts.mint.key();\n  \f\n  Ok(())\n\n}\n```\n\nKhi hàm thực thi initialize_candidate được gọi, chương trình sẽ khởi tạo một Candidate mới với:\n\n*  start_date và end_date được truyền ở thông số đầu vào.\n*  Giá trị amount ban đầu bằng 0.\n*  Loại token dùng để bầu được định nghĩa trong Context.\n### **Hàm vote**\nĐây là hàm bầu cử cho ứng viên được lựa chọn. Sau khi gọi hàm vote, ứng viên được bầu sẽ tăng số lượng phiếu bầu tương ứng với số token chỉ định. Token dùng để bầu sẽ được khoá tạm thời nhằm ngăn chặn Double Spend.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\npub struct Vote<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n)]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  #[account(\n    init_if_needed,\n    payer = authority,\n    space = Ballot::SIZE,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n)]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*   ballot: Địa chỉ phiếu bầu của người đi bầu và cũng là một PDA. Lần đầu bầu, phiếu bầu này sẽ được tạo mới. Những lần bầu tiếp theo chỉ cần cập nhật dữ liệu trên địa chỉ đã tạo.\n*   voter_token_account: Địa chỉ ví của cử tri chứa loại token dùng để bầu cử (tương ứng với mint trong thông tin ứng viên).\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Vote>, amount: u64) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.start_date || now > candidate.end_date {\n    return err!(ErrorCode::NotActiveCandidate);\n  }\n  let transfer_ctx = CpiContext::new(\n    ctx.accounts.token_program.to_account_info(),\n    token::Transfer {\n      from: ctx.accounts.voter_token_account.to_account_info(),\n      to: ctx.accounts.candidate_token_account.to_account_info(),\n      authority: ctx.accounts.authority.to_account_info(),\n  }, );\n  token::transfer(transfer_ctx, amount)?;\n  candidate.amount += amount;\n  ballot.authority = ctx.accounts.authority.key();\n  ballot.candidate = candidate.key();\n  ballot.amount += amount;\n  Ok(())\n}\n```\n\nKhi hàm thực thi hàm Vote được gọi, chương trình sẽ khởi tạo một Ballot mới nếu cần thiết. Sau đó kiểm tra xem còn trong thời hạn được phép bầu hay không. Nếu chưa đến hoặc quá thời gian bầu thì báo lỗi, còn không sẽ thực hiện bầu cho ứng viên. Chuyển số token tương ứng với số lượng bầu cho ứng viên vào kho chứa token của Candidate để khoá tạm thời. Sau đó cập nhật lại số lượng bầu cho ứng viên và phiếu bầu.\n\n### **Hàm close:**\nĐây là hàm để lấy lại token đã bầu sau khi thời gian bầu cử kết thúc. Nếu thời gian bầu cử chưa kết thúc không cho phép close. Token đã dùng để bầu cử sẽ được hoàn trả cho cử tri và xoá bỏ phiếu bầu.\n\n*Khai báo context*\n\n```ts\n#[derive(Accounts)]\n  pub struct Close<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\", &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n  )]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  // Wallet accounts\n  #[account(\n    mut,\n    close = authority,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n  )]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*  ballot, voter_token_account: có ý nghĩa tương tự hàm vote. Tuy nhiên Ballot sẽ được thu hồi sau khi thực hiện hàm close.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Close>) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.end_date {\n  return err!(ErrorCode::EndedCandidate);\n}\n\nlet seeds: &[&[&[u8]]] = &[&[\n  \"treasurer\".as_ref(),\n  &candidate.key().to_bytes(),\n  &[*ctx.bumps.get(\"treasurer\").unwrap()],\n]];\n\nlet transfer_ctx = CpiContext::new_with_signer(\n  ctx.accounts.token_program.to_account_info(),\n  token::Transfer {\n    from: ctx.accounts.candidate_token_account.to_account_info(),\n    to: ctx.accounts.voter_token_account.to_account_info(),\n    authority: ctx.accounts.authority.to_account_info(),\n  },\n  seeds,\n);\n\ntoken::transfer(transfer_ctx, ballot.amount)?;\nballot.amount = 0;\nOk(()) }\n```\n\nKhi hàm thực thi close được gọi, chương trình sẽ kiểm tra xem đã hết thời hạn bầu hay chưa.\n* Nếu chưa thì báo lỗi.\n* Nếu đã hết thời hạn bầu, hệ thống sẽ hoàn trả số token tương ứng với số lượng đã bầu. Sau đó thu hồi lại phiếu bầu.\n## **References**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp:[ https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev]( https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)",
      "title": "Xây dựng Solana DApp đầu tiên (P1)"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "423775549517": {
    "createdAt": 1651821841184,
    "updatedAt": 1652027219201,
    "thumbnail": "http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg",
    "category": [],
    "en": {
      "contents": "Xin chao, day la bai viet thu 10, test for từ khoá developer\n\n![](http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg)",
      "title": "Bai viet thu 10"
    },
    "vn": {
      "contents": "",
      "title": ""
    },
    "id": "423775549517"
  },
  "44439736980": {
    "createdAt": 1652148385472,
    "updatedAt": 1652327451322,
    "thumbnail": "https://academy.sentre.io/static/media/defi-thumbnail.e801bf2bffd3d758200f.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "vn": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "id": "44439736980"
  },
  "597285154092": {
    "createdAt": 1651638928963,
    "updatedAt": 1651639515583,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [],
    "en": {
      "contents": "Helo, this is 7th file",
      "title": "test 7th file"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "675051513086": {
    "createdAt": 1650971499311,
    "updatedAt": 1650971499311,
    "thumbnail": "",
    "category": [],
    "en": {
      "title": "Tiêu đề",
      "contents": "## Fig.1. World Map\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    },
    "vn": {
      "title": "Tiêu đề",
      "contents": "## Hình 1. Bản đồ thế giới\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    }
  },
  "739403395833": {
    "createdAt": 1651114236809,
    "updatedAt": 1652243050187,
    "thumbnail": "https://lh3.googleusercontent.com/LC-KSgoBprEUveCqmQnx8nhyVZBo4d2GkC9R6U7CTXgXXrjNUli7eajRWa7bY4hdG3EhMW569AT760wnFZxGRA4WJAsKG42s98AfMKCUFHSzw3d3ncdNSvb4duOGQvcazilvQU16",
    "category": [
      "Developer",
      "dev"
    ],
    "en": {
      "contents": "# Jobs Opportunity\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. World map*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. The same world map*\n\nTest: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Jobs Opportunity"
    },
    "vn": {
      "contents": "# Cơ hội nghề nghiệp\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. Bản đồ thế giới*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. Bản đồ thế giới tương tự*\n\nKiểm thử: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Cơ hội nghề nghiệp"
    },
    "id": "739403395833"
  },
  "975759747453": {
    "createdAt": 1652342850656,
    "updatedAt": 1652344187787,
    "thumbnail": "https://academy.sentre.io/static/media/mds-thumbnail.722db66a0b1a9e158dce.png",
    "category": [
      "dev",
      "blockchain",
      "solana"
    ],
    "en": {
      "contents": "Sau khi đã thiết kế giao diện và kết nối ví điện tử trên DApp của mình (tham khảo bài 2: [Thiết kế giao diện DApp](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)), bạn sẽ cần phải quản lý các dữ liệu liên quan tới DApp đó như: Wallet, Account, Balance, vân vân. Công cụ giúp bạn làm được việc này chính là Redux.\n\n\n\n## **Redux là gì?**\nRedux là một thư viện Javascript để quản lý state của ứng dụng, thường được sử dụng chung với ReactJS. Redux Toolkit là một thư viện giúp lập trình viên viết Redux dễ dàng và đơn giản hơn.\n\nỞ bài viết này, chúng ta sẽ cùng tìm hiểu nhanh về redux-toolkit và ứng dụng nhanh vào project của mình với một ví dụ đơn giản là tăng hoặc giảm một biến đếm counter.\n\n![redux life circle](https://i.2kvn.com/img/vib-2021-3eca7a19-82be-4c9f-8bfc-cbeac838106b.png)\n\n<br/>\n\n\n## **Cài đặt Redux Toolkit và React-Redux**\n### Bước 1. Mở Terminal và nhập lệnh\n```ts\n# NPM\nnpm install @reduxjs/toolkit react-redux\n```\n### Bước 2. Khởi tạo store\n* Store là 1 object chứa tất cả state toàn cục của ứng dụng.\n* Redux-toolkit: sử dụng configureStore để tạo store.\n* Tạo một tệp có tên src/store/index.ts. Import API configStore từ Redux-toolkit. Chúng ta sẽ bắt đầu bằng cách tạo Redux store trống và export nó, sau đó định nghĩa App State và Dispatch Types​ để tham chiếu khi cần sử dụng.\n\nFile: *src/store/index.ts*\n\n```ts\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport const store = configureStore({\n  reducer: {},\n})\n\n// Infer the 'AppState' and 'AppDispatch' types from the store itself\nexport type AppState = ReturnType<typeof store.getState>\n\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch\n```\n### Bước 3. Cung cấp Redux Store vào React App\nSau khi store được tạo, ở src/index.tsx, ta wrap <App/> bên trong một component hỗ trợ của react-redux là Provider. Nhờ đó tất cả component trong <App/> có thể truy cập được store.\n\nFile: *src/index.tsx*\n\n```ts\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { store } from \"store\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\ndocument.getElementById(\"root\")\n```\n### Bước 4. Tạo Redux State Slice\n* Tạo một file mới đặt tên src/store/counter.reducer.ts\n* File này import createSlice API từ Redux-toolkit. Redux-toolkit được sử dụng nhằm kết hợp giữa actions và reducers lại với nhau. Đó chính là nhiệm vụ của slice, được thực thi bằng hàm createSlice.\n\nFile: *src/store/counter.reducer.ts*\n\n```ts\nimport { createSlice } from \"@reduxjs/toolkit\";\n\n// Define a type for the slice state\ninterface CounterState {\n  value: number;\n}\n\n// Define the initial state using that type\nconst initialState: CounterState = {\n  value: 0\n};\n\nexport const counterSlice = createSlice({\n  name: \"counter\",\n\n  // 'createSlice' will infer the state type from the 'initialState' argument initialState,\n  reducers: {\n    increment: (state) => {\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n  }\n});\n\nexport const { increment, decrement } = counterSlice.actions;\nexport default counterSlice.reducer;\n```\n        \n### Bước 5. Thêm Slice Reducers vào Store\n\n* Chúng ta cần import counterReducer từ \"./counter.reducer\" đã được tạo ở trên và thêm nó vào store.\n* Bằng việc định nghĩa field bên trong biến reducer, chúng ta đã nói với store là hãy dùng các các slice reducer function để xử lý các cập nhật của state đó.\n\nFile: *src/store/index.ts*\n\n```ts\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"./counter.reducer\";\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer\n  }\n});\n\n// Infer the 'AppState' and 'AppDispatch' types from the store itself\nexport type AppState = ReturnType<typeof store.getState>;\n\n// Inferred type: {counter: counterState}\nexport type AppDispatch = typeof store.dispatch;\n```\n### Bước 6. Sử dụng redux tại component\nỞ src/components/counter/index.tsx ta sẽ:\n* Sử dụng useSelector của react-redux để lấy state counter từ store.\n* Sử dụng useDispatch để trả về function dispatch, truyền increment và decrement vào dispatch để gọi 2 action này.\n\nFile: *src/components/counter/index.tsx*\n\n```ts\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { AppState, AppDispatch } from \"store\";\nimport { increment, decrement } from \"store/counter.reducer\";\n\nconst Counter = () => {\n  const count = useSelector((state: AppState) => state.counter.value);\n  const dispatch = useDispatch<AppDispatch>();\n\n  return (\n    <div>\n      <div>Counter</div>\n      <button onClick={() => dispatch(increment())}>Increase Counter</button>\n      <button onClick={() => dispatch(decrement())}>Decrease Counter</button>\n      <p>Counter value: {count}</p>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n<br/>\n\n## **Ứng dụng vào project: Tạo Wallet Reducer**\nBước 1. Cài đặt React-Redux và Redux Toolkit\n\nBước 2. Khởi tạo store\n\nFile: *src/store/index.ts*\n\n```ts\nimport { configureStore } from \"@reduxjs/toolkit\";\n\nexport const store = configureStore({\n  reducer: {}\n});\n\n// Infer the 'AppState' and 'AppDispatch' types from the store itself\nexport type AppState = ReturnType<typeof store.getState>;\n\n// Inferred type: {wallet: WalletState}\nexport type AppDispatch = typeof store.dispatch;\n```\nBước 3. Cung cấp Redux Store vào React App\n\nFile: *src/index.tsx*\n\n```ts\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { WalletKitProvider } from \"@gokiprotocol/walletkit\";\n\nimport App from \"./App\";\nimport { store } from \"store\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n     <WalletKitProvider\n        defaultNetwork=\"devnet\"\n        app={{\n          name: \"My App\"\n        }}\n      >\n        <App />\n      </WalletKitProvider>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n```\nBước 4. Tạo Redux State Slice\n\nFile: *src/store/wallet.reducer.ts*\n\n```ts\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\n\nexport interface WalletState {\n  walletAddress: string;\n  balance: number;\n}\n\n// Define the initial state using that type\nconst initialState: WalletState = {\n  walletAddress: \"\",\n  balance: 0\n};\n\nexport const walletSlice = createSlice({\n  name: \"wallet\",\n  initialState,\n  reducers: {\n    // Use the PayloadAction type to declare the contents of 'action.payload'\n    setWalletInfo: (state, action: PayloadAction<WalletState>) => {\n    state.walletAddress = action.payload.walletAddress;\n    state.balance = action.payload.balance;\n    }\n  }\n});\n\nexport const { setWalletInfo } = walletSlice.actions;\nexport default walletSlice.reducer;\n```\nBước 5. Thêm Slice Reducers vào Store\n\n```ts\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport walletReducer from \"store/wallet.reducer\";\n\nexport const store = configureStore({\n  reducer: {\n    wallet: walletReducer\n  }\n});\n\n// Infer the 'AppState' and 'AppDispatch' types from the store itself\nexport type AppState = ReturnType<typeof store.getState>;\n\n// Inferred type: {wallet: WalletState}\nexport type AppDispatch = typeof store.dispatch;\n```\nBước 6. Sử dụng redux tại component\n\nFile: *src/App.tsx*\n\n```ts\nimport { useCallback, useEffect } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport {\n  useWalletKit,\n  useSolana,\n  useConnectedWallet\n} from \"@gokiprotocol/walletkit\";\n\nimport { Button, Col, Row, Space } from \"antd\";\nimport WalletInfo from \"components/walletInfo\";\nimport Transfer from \"components/transfer\";\n\nimport { AppDispatch } from \"store\";\nimport { setWalletInfo, WalletState } from \"store/wallet.reducer\";\n\nimport \"./App.css\";\n\nfunction App() {\n  // Goki hooks\n  const wallet = useConnectedWallet();\n  const { connect } = useWalletKit();\n  const { disconnect, providerMut } = useSolana();\n  const dispatch = useDispatch<AppDispatch>();\n\n  const fetchBalance = useCallback(async () => {\n    // TODO: fetch balance\n    let walletInfo: WalletState = {\n      walletAddress: wallet?.publicKey.toBase58() || \"\",\n      balance: 0\n    };\n    if (wallet && providerMut) {\n      walletInfo.balance = await providerMut.connection.getBalance(\n        wallet.publicKey\n      );\n    }\n    dispatch(setWalletInfo(walletInfo));\n  }, [providerMut, wallet]);\n\n  useEffect(() => {\n    fetchBalance();\n  }, [fetchBalance]);\n\n  return (\n    <Row justify=\"center\" gutter={[24, 24]}>\n      <Col span={12}>\n        <Row gutter={[24, 24]}>\n          <Col span={24} style={{ paddingTop: \"50px\" }}>\n            <WalletInfo />\n          </Col>\n          {/* Button connect wallet */}\n          <Col span={24} style={{ textAlign: \"center\" }}>\n            {wallet ? (\n              <Space>\n                <Button type=\"primary\" onClick={disconnect}>Disconnect</Button>\n                <Button type=\"primary\" onClick={fetchBalance}>Update Wallet</Button>\n              </Space>\n            ) : (\n              // Call connectWallet function when click Button\n              <Button type=\"primary\" onClick={connect}>Connect Wallet</Button>\n            )}\n          </Col>\n          <Col span={24}>\n            <Transfer />\n          </Col>\n        </Row>\n      </Col>\n    </Row>\n  );\n}\n\nexport default App;\n```\nĐây sẽ là giao diện khi chưa kết nối wallet:\n\n![wallet](https://lh6.googleusercontent.com/N-SnZT6RfJ9DI-u6qaizJNatyyYmDeQo67jRRU6sP_-y2ctsa2CTFVmBJmRunTkUqLdGeAENA2-WGI_HKWqy9whWcXRO8-rBE4iOC_AVosGe2GQCebyFjkW-9-D5qNUwEcFL4NFT)\n\nĐây là giao diện khi kết nối wallet:\n\n![wallet](https://lh6.googleusercontent.com/s7L8itiKGyjsXni2P7jHcZxsZPlsXH9pOD_bhhELOoIAj7Czc9BSOitUXk0K-kdYFEnl14rTsqeFd_G4g0w_uPHEZ5ke0X1cIvaqvOmwdb5-z5gCqmtaMXK8y8nnBFeGfKkN2USw)\n\nVà đây là giao diện khi đã kết nối thành công wallet:\n\n![](https://lh3.googleusercontent.com/zBXV_e1YLqzQvsWY0CcBY7iminzkgukLN1j6bNk5y5MjQ7cjOr1qUJD73oymISV-9CtLWQu2SyHsOsPdzhn4FGX7vZDxbQqnH-XyNfKohmmimi9W_h6zXSWuqeSTaCOxNVHX7XSq)\n\nDữ liệu wallet sẽ được lưu ở global store. Bất cứ component nào (ví dụ như Transfer) cần sử dụng đến dữ liệu này sẽ có thể truy cập để sử dụng, cũng như được cập nhật mới data khi store thay đổi.",
      "title": "Quản lý State của Dapp"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  }
}