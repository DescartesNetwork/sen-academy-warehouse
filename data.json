{
  "130904400097": {
    "createdAt": 1651633200923,
    "updatedAt": 1651636024778,
    "thumbnail": "",
    "category": [],
    "en": {
      "contents": "",
      "title": ""
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353825179923": {
    "createdAt": 1652327506346,
    "updatedAt": 1652328751944,
    "thumbnail": "https://academy.sentre.io/static/media/ds2-thumbnail.37b81891d1e8e3a58281.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong [Workshop 1](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev), chúng ta đã hoàn thành Solana program cho hệ thống bỏ phiếu có trọng số. Trong bài này, chúng ta sẽ cùng nhau phát triển giao diện đơn giản cũng như kết nối giao diện đó với Solana program để thực hiện việc giao tiếp cho hệ thống.\n\n\n## **Building the React App**\nTrong thư mục gốc của dự án Anchor, tạo một React app mới để ghi đè lên thư mục app hiện có:\n\n```ts\nnpx create-react-app app --template typescript\ncd app\n```\n\nTham khảo [bài số 2](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev) và [bài số 3](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev) để cài đặt ứng dụng cũng như các dependencies.\n\n\n### **Kết nối đến ví**\nỞ các bài trước, chúng ta đã tìm hiểu về Goki, cách kết nối ví và lưu thông tin ví vào Redux để có thể sử dụng, quản lý một cách hiệu quả. Tương tự như vậy, chúng ta ứng dụng lại vào chương trình và tạo kết nối đến ví người dùng.\n\n```ts\n// view/app/index.tsx\nimport { useCallback, useEffect } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { useWalletKit, useSolana, useConnectedWallet } from '@gokiprotocol/walletkit'\n\nimport { Button, Col, Layout, Row, Typography } from 'antd'\nimport ListCandidates from 'view/listCandidates'\nimport CandidateCreate from 'view/candidateCreate'\n\nimport { setWalletInfo, WalletState } from 'store/wallet.reducer'\nimport { AppDispatch } from 'store'\n\nconst { Header, Content } = Layout\n\nfunction App() {\n  const dispatch = useDispatch<AppDispatch>()\n  const wallet = useConnectedWallet()\n  const { connect } = useWalletKit()\n  const { providerMut } = useSolana()\n\n  const fetchWalletInfo = useCallback(async () => {\n    if (!wallet || !providerMut) return\n    // TODO: fetch SOL balance\n    const lamports = await providerMut.connection.getBalance(wallet.publicKey)\n    let walletInfo: WalletState = {\n      walletAddress: wallet.publicKey.toBase58(),\n      balance: lamports,\n    }\n    dispatch(setWalletInfo(walletInfo))\n  }, [providerMut, wallet])\n\n  useEffect(() => {\n    fetchWalletInfo()\n  }, [fetchWalletInfo])\n\n  return (\n    <Layout style={{ height: '100vh' }}>\n      <Header>\n        <Col span={24}>\n          {wallet ? (\n            <Col span={24} style={{ color: 'white' }}>\n              {wallet.publicKey.toBase58()}\n            </Col>\n          ) : (\n            <Button type=\"primary\" style={{ borderRadius: 40 }} onClick={connect}>\n              Connect Wallet\n            </Button>\n          )}\n        </Col>\n      </Header>\n      <Content style={{ padding: 40 }}>\n        <Row gutter={[24, 24]}>\n          <Col span={24}>\n            <Row gutter={[24, 24]}>\n              <Col flex=\"auto\">\n                <Typography.Title>List Candidates</Typography.Title>\n              </Col>\n              <Col>\n                <CandidateCreate />\n              </Col>\n            </Row>\n          </Col>\n          <Col span={24}>\n            <ListCandidates />\n          </Col>\n        </Row>\n      </Content>\n    </Layout>\n  )\n}\n\nexport default App\n```\n\n### **Giao diện bỏ phiếu**\n\n#### **Danh sách Candidate**\nGiao diện List candidates thể hiện cách thông tin: **candidate, start_date, end_date, …**\n\n\n![](https://academy.sentre.io/static/media/post-6-h1.a72f76ebb18473abedef.png)\n*Hình 1. Danh sách các ứng viên vào thông tin bỏ phiếu.*\n\n#### **Hàm khởi tạo ứng viên (New candidate)**\nGiao diện khởi tạo candidate cần các thông tin cơ bản như địa chỉ token để bỏ phiếu, ngày bắt đầu, ngày kết thúc bỏ phiếu.\n\n\n![](https://academy.sentre.io/static/media/post-6-h2.ba78517cd8d683ad0e10.png)\n*Hình 2. Giao diện khởi tạo thông tin cho ứng viên.*\n\n#### **Hàm bỏ phiếu (Vote)**\n\n\n![](https://academy.sentre.io/static/media/post-6-h3.1e5b88f42343e518990e.png)\n*Hình 3. Cử tri nhập số lượng tokens để bầu cho ứng viên.*\n\n### **Kết nối đến Solana Program (Smart Contract)**\n\nSao chép tệp **target/types/l6.ts** vào thư mục **app/config** và đặt tên **idl.ts**. Tệp này giúp định nghĩa các giao diện (interface) của Solana program. Nó giúp các chương trình off-chain, có thể là frontend hoặc backend với các ngôn ngữ khác nhau, biết các để giao tiếp với chương trình chạy on-chain. Nếu các bạn đã quen thuộc với Ethereum thì tệp IDL này có ý nghĩa tương đương với ABI.\n\nTiếp đến chúng ta phải tạo file config để định nghĩa kết nối. Cụ thể là mạng **devnet**.\n\n```ts\n// app/src/config/index.ts\nimport * as anchor from '@project-serum/anchor'\nimport { clusterApiUrl } from '@solana/web3.js'\n\nimport { IDL } from './idl'\n\nexport const DEFAULT_COMMITMENT = 'confirmed'\nexport const DEFAULT_CLUSTER = 'devnet'\nexport const PROGRAM_ADDRESS = new anchor.web3.PublicKey(\n  'HCoUastFpW7wB9Ue4o4YHy27VTuiJEo7h9hKmhnXDQhD',\n)\nexport const NODE_URL = clusterApiUrl(DEFAULT_CLUSTER)\n\nexport type CandidateData = {\n  address: string\n  mint: string\n  amount: number\n  startTime: number\n  endTime: number\n}\n\n// Function support\nexport const getProvider = (wallet: any) => {\n  const connection = new anchor.web3.Connection(NODE_URL, DEFAULT_COMMITMENT)\n  return new anchor.Provider(connection, wallet, {\n    preflightCommitment: DEFAULT_COMMITMENT,\n  })\n}\n\nexport const getProgram = (wallet: any) => {\n  const provider = getProvider(wallet)\n  return new anchor.Program(IDL, PROGRAM_ADDRESS, provider)\n}\n```\n\n\nViết hàm gọi và truyền vào các tham số định nghĩa ở IDL để tạo ứng viên\n\n```ts\nawait program.rpc.initializeCandidate(new anchor.BN(startTime), new anchor.BN(endTime), {\n  accounts: {\n    authority: wallet.publicKey,\n    candidate: candidate.publicKey,\n    treasurer,\n    mint: new anchor.web3.PublicKey(mintAddress),\n    candidateTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [candidate],\n})\n```\n\nTạo hàm bỏ phiếu cho ứng viên\n\n```ts\nawait program.rpc.vote(new anchor.BN(amount), {\n    accounts: {\n    authority: wallet.publicKey,\n    candidate: candidatePublicKey,\n    treasurer,\n    mint: candidateData.mint,\n    candidateTokenAccount,\n    ballot,\n    voterTokenAccount: walletTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [],\n  })\n```\n\nTạo hàm close vote\n\n```ts\nawait program.rpc.close({\naccounts: {\n  authority: wallet.publicKey,\n  candidate: candidatePublicKey,\n  treasurer,\n  mint: candidateData.mint,\n  candidateTokenAccount,\n  ballot,\n  voterTokenAccount: walletTokenAccount,\n  tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n  associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n  systemProgram: anchor.web3.SystemProgram.programId,\n  rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n},\nsigners: [],\n})\n```\n\n## **Tham khảo**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp: [https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)\n\nPDA và chuẩn SPLT trong lập trình Solana: [https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev](https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev)\n\nXây dựng DApp đầu tiên trên Solana (phần 1): [https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev)",
      "title": "Xây dựng Solana DApp đầu tiên (P2)"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353917979844": {
    "createdAt": 1651640470205,
    "updatedAt": 1651822151703,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [
      "user"
    ],
    "en": {
      "contents": "\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nSome useful information that you can also consider as below:\n-  ....",
      "title": "8th Post"
    },
    "vn": {
      "contents": "Tiếng việt phiên bản\n\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nCác thông tin hữu ích như dưới đây:\n-  ....",
      "title": "Bài viết số 8"
    }
  },
  "423086673347": {
    "createdAt": 1652328797208,
    "updatedAt": 1652339528367,
    "thumbnail": "https://academy.sentre.io/static/media/ds-thumbnail.4bb629ac92820acea899.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Sau khi hoàn thành 5 bài đầu tiên trong chuỗi 10 bài, chúng ta đã được trang bị các kiến thức cơ bản nhất để xây dựng một DApp hoàn chỉnh. Để giúp bạn đọc có thể hệ thống lại kiến thức, bài viết xin nhắc lại các kiến thức đã học gồm:\n\n* ReactJS - giúp phát triển ứng dụng nền Web.\n* Ant Design - giúp xây dựng nhanh chóng giao diện người dùng bằng các thành phần dựng sẵn.\n* Redux Toolkit - giúp quản lý trạng thái của ứng dụng với số lượng dữ liệu và trạng thái phức tạp.\n* Anchor - giúp phát triển chương trình chạy được trên chuỗi khối. Solana dùng thuật ngữ program, hoặc Ethereum dùng thuật ngữ smart contract để ám chỉ chương trình này.\n\nTrong bài này chúng ta sẽ kết hợp tất cả chúng lại để xây dựng một ứng dụng bỏ phiếu một cách hoàn chỉnh nhất.\n\n## **Hệ thống bỏ phiếu điện tử có trọng số (Weighted eVoting System)**\nTrong phần này chúng ta sẽ đi phân tích xem để hiểu được hệ thống bỏ phiếu điện tử có trọng số (sau đây sẽ gọi ngắn gọn là hệ thống) có những đặc tính cơ bản nào.\n\n### **Phiếu bầu có trọng số**\nĐối với các hệ thống bỏ phiếu phổ biến, đa số chúng đều là không trọng số. Nghĩa là mọi người bỏ phiếu (voter) đều có “sức mạnh” như nhau và bằng chính xác 1 lá phiếu. Dù bạn rất nổi tiếng, hay bạn là một sinh viên, thì lá phiếu của bạn đều chỉ được tính là 1. Ngược lại, trong hệ thống có trọng số, yếu tố “sức mạnh” được xem xét đến trong quá trình kiểm phiếu. Cụ thể hơn,\n\ntrên môi trường blockchain, số lượng một token cụ thể bạn đang nắm sẽ đại diện cho sức mạnh lá phiếu của bạn.\n\n* hình 1, người bỏ phiếu có 10 tokens và anh ấy có thể dùng 10 tokens đó để đại diện cho “sức mạnh” lá phiếu bầu. Ví dụ, anh ấy bỏ phiếu cho Candidate #1, thì hệ thống sẽ ghi nhận Cadidate #1 được cộng thêm 10 điểm.\n\n\n![](https://academy.sentre.io/static/media/post-5-weight.46eaad4973b1f98b7529.png)\n### **Double Spend**\nDouble Spend hay “Dùng hai lần” là một hình thức gian lận giúp người dùng có thể sử dụng nhiều hơn một lần bằng 1 số lượng tokens cụ thể. Trong phạm vi hệ thống, sử dụng được hiểu theo nghĩa là bỏ phiếu. Giả sử như sau khi bỏ phiếu bằng ví số 1, người dùng cố tình chuyển số tokens ban đầu sang một ví số 2 nhằm thực hiện lại hành vi bỏ phiếu không hợp lệ. Tiếp tục như vậy, với chỉ 10 tokens, người dùng có thể bỏ phiếu vô số lần.\n\nĐể đảm bảo được tính công bằng, với mỗi lượt bỏ phiếu, số token của người dùng phải được khoá trong thời gian bỏ phiếu. Cơ chế khoá được hiện thực đơn giản bằng cách chuyển token người dùng vào một ví tạm thời và chỉ hệ thống mới có thể kiểm soát ví đó. Hết thời hạn bỏ phiếu, số token sẽ được trả lại chính xác cho người bỏ phiếu.\n\n \n\n![](https://academy.sentre.io/static/media/post-5-weight-2.8ba8bcc02fe2f5db029b.png)\n*Hình 2. Token người dùng sẽ được khoá tạm thời trong thời gian bỏ phiếu. Số token này sẽ đc hoàn trả khi kết thúc bỏ phiếu.*\n\n## **Hiện thực hệ thống**\n### **Khai báo Schema**\n#### **Candidate**\n\nMỗi ứng viên sẽ được tạo một tài khoản trên chuỗi khối nhằm ghi nhận số lượng người bỏ phiếu cũng như quản lý các thông tin cần thiết cho việc bỏ phiếu. Để cho đơn giản, ở đây bài viết lược bỏ đi khá nhiều thông tin và chỉ giữ lại các thông tin cơ bản nhất.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-3.43baaffb217762c92a1f.png\">\n</p>\n\n*Hình 3. Thông tin ứng viên (Candidate schema)*\n\n* mint: Loại token được dùng để bỏ phiếu.\n* amount: số lượng token bầu cho ứng viên.\n* start_date: Thời gian bắt đầu cho phép bỏ phiếu\n* end_date: Thời gian kết thúc bỏ phiếu.\n\n**Ballot**\n\nPhiếu bầu dùng để lưu trữ thông tin bỏ phiếu của từng người tham gia hệ thống. Lá phiếu sẽ dùng để xác thực việc hoàn trả token sau này.\n\n \n\n<p align=\"center\">\n  <img src=\"https://academy.sentre.io/static/media/post-5-weight-4.3e0b193bdad8878523f4.png\">\n</p>\n\n*Hình 4: Thông tin phiếu bầu (Ballot schema)*\n\n## **Khai báo Instructions**\n### **Hàm initialize_candidate:**\nĐây là hàm giúp khởi tạo ứng viên mới. Khi muốn tạo mới ứng viên cho việc bầu cử cần gọi hàm **initialize_candidate**. Ứng viên sẽ được tạo mới với các dữ liệu mặc định.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\n\npub struct InitializeCandidate<'info> {\n\n  #[account(mut)]\n\n  pub authority: Signer<'info>,\n\n  #[account(\n\n    init,\n\n    payer = authority,\n\n    space = Candidate::SIZE,\n\n  )]\n\n  pub candidate: Account<'info, Candidate>,\n  \f\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n\n  CHECK: Just a pure account\n\n  pub treasurer: AccountInfo<'info>,\n\n  pub mint: Box<Account<'info, token::Mint>>, #[account(\n\n    init,\n\n    payer = authority,\n\n    associated_token::mint = mint, associated_token::authority = treasurer\n  )]\n\n  pub candidate_token_account: Account<'info, token::TokenAccount>, // System Program Address\n\n  pub system_program: Program<'info, System>,\n\n  pub token_program: Program<'info, token::Token>,\n\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n\n  pub rent: Sysvar<'info, Rent>,\n\n}\n```\n* **authority**: Địa chỉ ví thực hiện và trả phí giao dịch\n* **candidate**: Địa chỉ ứng viên. Mỗi ứng viên khác nhau có địa chỉ candidate khác nhau.\n* **treasurer**: Địa chỉ PDA quản lý candidate token account. Được tạo thành với seeds là “treasurer” và địa chỉ của candidate. Vậy nên candidate khác nhau có treasurer khác nhau.\n* Đối với những loại account không có kiểu dữ liệu cụ thể, cần thêm: /// CHECK:\n  Just a pure account\n* **mint**: Loại token được dùng để bỏ phiếu\n* **candidate_token_account**: Địa chỉ Token Account dùng để khoá tạm thời token để ngăn tấn công Double Spend.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<InitializeCandidate>, start_date: i64, end_date: i64) -> Result<()>\n{\n\n  let candidate = &mut ctx.accounts.candidate;\n\n  candidate.start_date = start_date;\n\n  candidate.end_date = end_date;\n\n  candidate.amount = 0;\n\n  candidate.mint = ctx.accounts.mint.key();\n  \f\n  Ok(())\n\n}\n```\n\nKhi hàm thực thi initialize_candidate được gọi, chương trình sẽ khởi tạo một Candidate mới với:\n\n*  start_date và end_date được truyền ở thông số đầu vào.\n*  Giá trị amount ban đầu bằng 0.\n*  Loại token dùng để bầu được định nghĩa trong Context.\n### **Hàm vote**\nĐây là hàm bầu cử cho ứng viên được lựa chọn. Sau khi gọi hàm vote, ứng viên được bầu sẽ tăng số lượng phiếu bầu tương ứng với số token chỉ định. Token dùng để bầu sẽ được khoá tạm thời nhằm ngăn chặn Double Spend.\n\n*Khai báo Context*\n\n```ts\n#[derive(Accounts)]\npub struct Vote<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\".as_ref(), &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n)]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  #[account(\n    init_if_needed,\n    payer = authority,\n    space = Ballot::SIZE,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n)]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*   ballot: Địa chỉ phiếu bầu của người đi bầu và cũng là một PDA. Lần đầu bầu, phiếu bầu này sẽ được tạo mới. Những lần bầu tiếp theo chỉ cần cập nhật dữ liệu trên địa chỉ đã tạo.\n*   voter_token_account: Địa chỉ ví của cử tri chứa loại token dùng để bầu cử (tương ứng với mint trong thông tin ứng viên).\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Vote>, amount: u64) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.start_date || now > candidate.end_date {\n    return err!(ErrorCode::NotActiveCandidate);\n  }\n  let transfer_ctx = CpiContext::new(\n    ctx.accounts.token_program.to_account_info(),\n    token::Transfer {\n      from: ctx.accounts.voter_token_account.to_account_info(),\n      to: ctx.accounts.candidate_token_account.to_account_info(),\n      authority: ctx.accounts.authority.to_account_info(),\n  }, );\n  token::transfer(transfer_ctx, amount)?;\n  candidate.amount += amount;\n  ballot.authority = ctx.accounts.authority.key();\n  ballot.candidate = candidate.key();\n  ballot.amount += amount;\n  Ok(())\n}\n```\n\nKhi hàm thực thi hàm Vote được gọi, chương trình sẽ khởi tạo một Ballot mới nếu cần thiết. Sau đó kiểm tra xem còn trong thời hạn được phép bầu hay không. Nếu chưa đến hoặc quá thời gian bầu thì báo lỗi, còn không sẽ thực hiện bầu cho ứng viên. Chuyển số token tương ứng với số lượng bầu cho ứng viên vào kho chứa token của Candidate để khoá tạm thời. Sau đó cập nhật lại số lượng bầu cho ứng viên và phiếu bầu.\n\n### **Hàm close:**\nĐây là hàm để lấy lại token đã bầu sau khi thời gian bầu cử kết thúc. Nếu thời gian bầu cử chưa kết thúc không cho phép close. Token đã dùng để bầu cử sẽ được hoàn trả cho cử tri và xoá bỏ phiếu bầu.\n\n*Khai báo context*\n\n```ts\n#[derive(Accounts)]\n  pub struct Close<'info> {\n  // TODO: Customize account address\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  #[account(mut, has_one = mint)]\n  // Candidate accounts\n  pub candidate: Account<'info, Candidate>,\n  #[account(seeds = [b\"treasurer\", &candidate.key().to_bytes()], bump)]\n  /// CHECK: Just a pure account\n  pub treasurer: AccountInfo<'info>,\n  pub mint: Box<Account<'info, token::Mint>>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = treasurer\n  )]\n  pub candidate_token_account: Account<'info, token::TokenAccount>,\n  // Wallet accounts\n  #[account(\n    mut,\n    close = authority,\n    seeds = [b\"ballot\".as_ref(), &candidate.key().to_bytes(), &authority.key().to_bytes()],\n    bump\n  )]\n  pub ballot: Account<'info, Ballot>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = authority\n  )]\n  pub voter_token_account: Account<'info, token::TokenAccount>,\n  // System Program Address\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, token::Token>,\n  pub associated_token_program: Program<'info, associated_token::AssociatedToken>,\n  pub rent: Sysvar<'info, Rent>,\n}\n```\n* authority, candidate, treasurer, mint, candidate_token_account: có ý nghĩa tương tự hàm initialize_candidate.\n*  ballot, voter_token_account: có ý nghĩa tương tự hàm vote. Tuy nhiên Ballot sẽ được thu hồi sau khi thực hiện hàm close.\n\n*Viết hàm thực thi*\n\n```ts\npub fn exec(ctx: Context<Close>) -> Result<()> {\n  let candidate = &mut ctx.accounts.candidate;\n  let ballot = &mut ctx.accounts.ballot;\n  let now = Clock::get().unwrap().unix_timestamp;\n  if now < candidate.end_date {\n  return err!(ErrorCode::EndedCandidate);\n}\n\nlet seeds: &[&[&[u8]]] = &[&[\n  \"treasurer\".as_ref(),\n  &candidate.key().to_bytes(),\n  &[*ctx.bumps.get(\"treasurer\").unwrap()],\n]];\n\nlet transfer_ctx = CpiContext::new_with_signer(\n  ctx.accounts.token_program.to_account_info(),\n  token::Transfer {\n    from: ctx.accounts.candidate_token_account.to_account_info(),\n    to: ctx.accounts.voter_token_account.to_account_info(),\n    authority: ctx.accounts.authority.to_account_info(),\n  },\n  seeds,\n);\n\ntoken::transfer(transfer_ctx, ballot.amount)?;\nballot.amount = 0;\nOk(()) }\n```\n\nKhi hàm thực thi close được gọi, chương trình sẽ kiểm tra xem đã hết thời hạn bầu hay chưa.\n* Nếu chưa thì báo lỗi.\n* Nếu đã hết thời hạn bầu, hệ thống sẽ hoàn trả số token tương ứng với số lượng đã bầu. Sau đó thu hồi lại phiếu bầu.\n## **References**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp:[ https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev]( https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)",
      "title": "Xây dựng Solana DApp đầu tiên (P1)"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "423775549517": {
    "createdAt": 1651821841184,
    "updatedAt": 1652027219201,
    "thumbnail": "http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg",
    "category": [],
    "en": {
      "contents": "Xin chao, day la bai viet thu 10, test for từ khoá developer\n\n![](http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg)",
      "title": "Bai viet thu 10"
    },
    "vn": {
      "contents": "",
      "title": ""
    },
    "id": "423775549517"
  },
  "44439736980": {
    "createdAt": 1652148385472,
    "updatedAt": 1652327451322,
    "thumbnail": "https://academy.sentre.io/static/media/defi-thumbnail.e801bf2bffd3d758200f.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "vn": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "id": "44439736980"
  },
  "597285154092": {
    "createdAt": 1651638928963,
    "updatedAt": 1651639515583,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [],
    "en": {
      "contents": "Helo, this is 7th file",
      "title": "test 7th file"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "675051513086": {
    "createdAt": 1650971499311,
    "updatedAt": 1650971499311,
    "thumbnail": "",
    "category": [],
    "en": {
      "title": "Tiêu đề",
      "contents": "## Fig.1. World Map\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    },
    "vn": {
      "title": "Tiêu đề",
      "contents": "## Hình 1. Bản đồ thế giới\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    }
  },
  "739403395833": {
    "createdAt": 1651114236809,
    "updatedAt": 1652243050187,
    "thumbnail": "https://lh3.googleusercontent.com/LC-KSgoBprEUveCqmQnx8nhyVZBo4d2GkC9R6U7CTXgXXrjNUli7eajRWa7bY4hdG3EhMW569AT760wnFZxGRA4WJAsKG42s98AfMKCUFHSzw3d3ncdNSvb4duOGQvcazilvQU16",
    "category": [
      "Developer",
      "dev"
    ],
    "en": {
      "contents": "# Jobs Opportunity\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. World map*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. The same world map*\n\nTest: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Jobs Opportunity"
    },
    "vn": {
      "contents": "# Cơ hội nghề nghiệp\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. Bản đồ thế giới*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. Bản đồ thế giới tương tự*\n\nKiểm thử: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Cơ hội nghề nghiệp"
    },
    "id": "739403395833"
  }
}