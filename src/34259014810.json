{
  "createdAt": 1653980764624,
  "updatedAt": 1653983760316,
  "thumbnail": "https://i.imgur.com/yZJu3w8.png",
  "category": [
    "solana",
    "web3camp",
    "dev"
  ],
  "en": {
    "contents": "Privacy Finance (PriFi) hay Tài chính “riêng tư” là một khái niệm rất mới và có bắt đầu nở rộ trong những năm gần đây. Thực chất, sự riêng tư trong tài chính phi tập trung đã hình thành từ khá sớm cùng với sự hình thành của công nghệ chuỗi khối. Dash (1/2014), Moreno (4/2014), ZCash (10/2016) những chuỗi khối nhằm bảo vệ thông tin giao dịch và đảm bảo quyền riêng tư cho người dùng. Trong đó Dash sử dụng mixnet để làm rối giao dịch, còn Monero và Zcash sử dụng zero-knowledge proof để giấu số dư nhưng vẫn giữ nguyên tính sở hữu của giao dịch. Với động lực phát triển của DeFi, PriFi đang dần quay trở lại như một “lớp riêng tư” (Privacy Layer) bổ sung cho thị trường hiện có. Ví dụ nổi tiếng nhất là Tornado.cash (12/2019) trên mạng Ethereum, và Blender.io cho đồng tiền Bitcoin.\n\nTrong bài này, chúng ta sẽ thử xây dựng một bản mẫu cho một máy trộn trên Solana. (Lưu ý, các phép tính trên hệ mật mã sẽ được dự kiến triển khai trong phiên bản 1.11.0, các phiên bản cũ hơn sẽ không thể hoàn thành bản mẫu được đề xuất trong bài.)\n\n<iframe width=\"100%\" height=\"512\" src=\"https://www.youtube.com/embed/vbGo5YfeTiI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n# Nền tảng về mật mã\n\n## Hệ mã Đường cong Elliptic\n\n<img style=\"max-width:1024px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/SdoSGqh.png\" alt=\"elliptic\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 1: Đường cong Elliptic và phép toán cộng 2 điểm trên đường cong.</p>\n\nĐường cong Elliptic có phương trình dạng $y=x^3+ax+b$ với phép toán cộng 2 điểm được xác định như sau: Cho $P$ và $Q$ là 2 điểm trên đường cong, $R=P+Q$ khi đó $R$ là điểm đối xứng qua trục hoành với giao điểm của đường cong Elliptic và đường thẳng qua $P$ và $Q$. Nếu giao điểm trên không tồn tại, tổng được xác định bằng $0$.\n\nNhư một hệ quả, phép nhân $nP$ chính là biểu diễn của phép cộng $n$ lần $P$.\n\n## Độ khó\n\nĐộ khó chính là nền tảng cho sự hình thành của mọi hệ mật mã. Trong Đường cong Elliptic, cho 2 điểm ngẫu nhiên $P$ và $Q$ và tìm $n$ sao cho $nP=Q$ được xem là một vấn đề khó. Hiện không có thuật toán tối ưu nào có thể giải được trong một khoảng thời gian khả thi.\n\nTuy việc tìm $n$ là rất khó nhưng việc kiểm tra $n$ sao cho $nP=Q$ lại rất nhanh và đơn giản. Từ tính chất trên các giao thức về bảo mật được xây dựng trong đó có thể kể đến hàm băm Pedersen, [khoá công khai](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), [chữ ký số](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm), [khoá trao đổi](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman), …\n\n## Phép đồng cấu\n\nGọi $f(x)=xG$ trong đó $G$ là điểm sinh trên một đường cong Elliptic (một cách dễ hiểu, $G$ là điểm được quy định sẵn). Vì $f(x+y)=f(x)+f(y)$ nên $f$ được gọi là một phép đồng cấu. Vậy phép nhân với số nguyên (hoặc nhân với phần tử trong tập hữu hạn) được xem là một phép đồng cấu cho đường cong Elliptic khi mà $(x+y)G=xG+yG$.\n\nNgoài ra, ta cũng thấy một tính chất của hàm $f(x)=xG$ trong đường cong Elliptic là $yf(x)=xf(y)$.\n\n# Ý tưởng máy trộn giao dịch\n\nÝ tưởng về máy trộn được xây dựng dựa trên một hình thức trò chơi giải đố. Giả sử Alice tạo nên một câu đố $Q$ và gửi kèm cùng một số lượng $\\alpha$ tokens lên chương trình trên chuỗi khối. Nhiệm vụ của chương trình này là kiểm tra nếu bất kỳ ai có câu trả lời $A$ thoả mãn $Q$ sẽ được nhận $\\alpha$. Câu đố đặt ra phải được xác định là một vấn đề khó, chỉ có Alice, hoặc Bob người được Alice tiết lộ câu trả lời $A$ mới có thể giải đố và nhận về $\\alpha$.\n\nTuy nhiên, thực sự liên kết giữa ngươi gửi và người nhận vẫn chưa thật sự được cắt đứt khi mà Alice có liên kết với $Q$, $Q$ lại liên kết với $A$, và $A$ lại liên kết Bob, nên rốt cuộc vẫn là Alice gửi tiền cho Bob. Để cắt đứt liên kết này, chúng ta phải cắt đứt liên kết giữ $Q$ và $A$ bằng một cơ chế trộn.\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/3XLOU3d.png\" alt=\"mixer\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 2. Máy trộn giúp cắt đứt liên hệ giữa Q và A trong khi vẫn đám bảo chính xác quá trình kiểm tra.</p>\n\n# Hiện thực máy trộn\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/N9lWlMB.png\" alt=\"mechanism\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 3. Mô tả cơ chế trộn của một vòng trộn cho 3 câu đố.</p>\n\n**Câu đố.** Với đường cong Elliptic và điểm $G$ được quy định chung, cho $P$ là một điểm trên đường cong, xác định $x$ sao cho $P=xG$.\n\nĐể sinh ra một câu đố như trên, Alice lấy ngẫu nhiên một giá trị $x$, tính $P=xG$ và gửi $P$ cùng với, ví dụ, 1 SOL lên chương trình kiểm chứng.\n\n**Cơ chế trộn.** Phép trộn được thực hiện lặp lại nhiều vòng cho tập hợp các câu đố $[P]$, và ở mỗi vòng các bước thực hiện là như nhau. Cho $n$ máy trộn $M_{0..n-1}$, và một phép hoán vị $\\pi$, vòng trộn thứ $j$ được diễn ra như sau:\n\n1. Mỗi máy trộn $M_i$ chọn một giá trị ngẫu nhiên $z_i$, sau đó tính toán và nộp giá trị $[P]_j=\\pi(z_i[P]_{j-1})$ và $Gj=z_iG_{j-1}$ cùng với một số tiền cọc, ví dụ 10 SOL, lên chương trình kiểm chứng. Trong đó $G_0=G$ và $[P]_0=[P]$.\n2. Máy kiếm chứng sẽ chọn ngẫu nhiên một máy trộn và chấp nhận giá trị nộp từ máy trộn đó: $[P]_j=\\pi(z_i[P]_{j-1})$, $G_j=z_iG_{j-1}$.\n3. Tất cả các máy trộn không được chọn phải tiết lộ giá trị $z$ để chứng minh không ứng xử sai trong các bước trước và lấy lại 10 SOL.\n\nTa thấy bằng cách nhân với $z$ cũng như hoán vị bởi $\\pi$, vị trí của các câu hỏi đã bị thay đổi và không thể truy vết. Tuy nhiên câu trả lời vẫn không thay đổi vì $P=xG \\Leftrightarrow zP=xzG$. Càng nhiều vòng trộn được diễn ra, càng khó truy vết được giao dịch gốc.\n\nNgoài ra, các máy trộn cũng bị triệt tiêu động cơ làm sai khi mà ở xác suất bị phát hiện và mất khoảng cọc là rất cao.\n\n**Hoàn tiền.** Sau khi trải qua k lần trộn và đủ an toàn, người dùng có thể dùng $x$ để lần lượt kiểm tra $P_k$ nào tương ứng với $x$. Nộp $(x,P_k)$ lên chương trình và nhận lại 1 SOL.\n\n# Thiết kế hệ thống\n\n**Hồ câu đố.** Tương tự như Tornado.cash, hệ thống sẽ có các hồ 0.1 SOL, 1 SOL, 10 SOL, 100 SOL, 1000 SOL. Các câu đố sẽ được phân loại vào hồ tương ứng dựa trên lựa SOL được chuyển. Giả sử Alice muốn chuyển 10.1 SOL, Alice phải tạo 2 cấu đố P1, P2, trong đó P1 sẽ vào hồ 0.1 SOL và P2 sẽ vào 10 SOL.\n\n**Cụm Trộn.** Để tham gia và cụm máy trộn, các máy trộn đơn lẻ phải cọc tiền. Khi hệ thống một máy trộn cố tình gian lận, khoảng tiền cọc này sẽ bị tịch thu như 1 khoảng phạt. Mỗi hồ sẽ có một cụm trộn để thực hiện việc trộn.\n\n**Phí.** Khi nhận tiền về, người dùng phải trả một khoảng phí, ví dụ 0.0005 SOL, cho hồ tương ứng. Định kỳ khoảng phí này sẽ được chia lại cho các máy trộn trong cụm trộn.\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/lmRIRQe.png\" alt=\"infra\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 4: Hệ thống máy trộn và mô hình phí.</p>\n\n# Lời kết\n\nHệ thống máy trộn trên dựa nhiều vào ý tưởng [mixnet](https://en.wikipedia.org/wiki/Mix_network), trong khi Tornado.cash dự nhiều vào [zero-knowledge proof](https://en.wikipedia.org/wiki/Zero-knowledge_proof), tuy vậy cả hai vẫn đạt được mục tiêu xoá vết giữa người gửi và người nhận. Zero-knowledge proof gần như không yêu cầu cụm máy trộn, tuy nhiên đòi hỏi khối lượng tính toán lớn hơn. Mixnet thì ngược lại khi mà khối lượng tính toán đơn giản nhưng yêu cầu cụm máy trộn để thực hiện các bước cần thiết.\n\n<br/><button data-tf-popup=\"Ij8yEHDC\" data-tf-iframe-props=\"title=[Vietnam Web3 Camp] Bài tập số 10\" data-tf-medium=\"snippet\" style=\"all:unset;font-family:Helvetica,Arial,sans-serif;display:inline-block;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;background-color:#F9575E;color:#FFFFFF;font-size:20px;border-radius:12px;padding:0 33px;font-weight:bold;height:50px;cursor:pointer;line-height:50px;text-align:center;margin:0;text-decoration:none;margin:auto;display:block;\">Làm bài tập</button><script src=\"//embed.typeform.com/next/embed.js\"></script>",
    "title": "Những ví dụ kinh điển trong PriFi"
  },
  "vn": {
    "contents": "Privacy Finance (PriFi) hay Tài chính “riêng tư” là một khái niệm rất mới và có bắt đầu nở rộ trong những năm gần đây. Thực chất, sự riêng tư trong tài chính phi tập trung đã hình thành từ khá sớm cùng với sự hình thành của công nghệ chuỗi khối. Dash (1/2014), Moreno (4/2014), ZCash (10/2016) những chuỗi khối nhằm bảo vệ thông tin giao dịch và đảm bảo quyền riêng tư cho người dùng. Trong đó Dash sử dụng mixnet để làm rối giao dịch, còn Monero và Zcash sử dụng zero-knowledge proof để giấu số dư nhưng vẫn giữ nguyên tính sở hữu của giao dịch. Với động lực phát triển của DeFi, PriFi đang dần quay trở lại như một “lớp riêng tư” (Privacy Layer) bổ sung cho thị trường hiện có. Ví dụ nổi tiếng nhất là Tornado.cash (12/2019) trên mạng Ethereum, và Blender.io cho đồng tiền Bitcoin.\n\nTrong bài này, chúng ta sẽ thử xây dựng một bản mẫu cho một máy trộn trên Solana. (Lưu ý, các phép tính trên hệ mật mã sẽ được dự kiến triển khai trong phiên bản 1.11.0, các phiên bản cũ hơn sẽ không thể hoàn thành bản mẫu được đề xuất trong bài.)\n\n<iframe width=\"100%\" height=\"512\" src=\"https://www.youtube.com/embed/vbGo5YfeTiI\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n# Nền tảng về mật mã\n\n## Hệ mã Đường cong Elliptic\n\n<img style=\"max-width:1024px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/SdoSGqh.png\" alt=\"elliptic\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 1: Đường cong Elliptic và phép toán cộng 2 điểm trên đường cong.</p>\n\nĐường cong Elliptic có phương trình dạng $y=x^3+ax+b$ với phép toán cộng 2 điểm được xác định như sau: Cho $P$ và $Q$ là 2 điểm trên đường cong, $R=P+Q$ khi đó $R$ là điểm đối xứng qua trục hoành với giao điểm của đường cong Elliptic và đường thẳng qua $P$ và $Q$. Nếu giao điểm trên không tồn tại, tổng được xác định bằng $0$.\n\nNhư một hệ quả, phép nhân $nP$ chính là biểu diễn của phép cộng $n$ lần $P$.\n\n## Độ khó\n\nĐộ khó chính là nền tảng cho sự hình thành của mọi hệ mật mã. Trong Đường cong Elliptic, cho 2 điểm ngẫu nhiên $P$ và $Q$ và tìm $n$ sao cho $nP=Q$ được xem là một vấn đề khó. Hiện không có thuật toán tối ưu nào có thể giải được trong một khoảng thời gian khả thi.\n\nTuy việc tìm $n$ là rất khó nhưng việc kiểm tra $n$ sao cho $nP=Q$ lại rất nhanh và đơn giản. Từ tính chất trên các giao thức về bảo mật được xây dựng trong đó có thể kể đến hàm băm Pedersen, [khoá công khai](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), [chữ ký số](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm), [khoá trao đổi](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman), …\n\n## Phép đồng cấu\n\nGọi $f(x)=xG$ trong đó $G$ là điểm sinh trên một đường cong Elliptic (một cách dễ hiểu, $G$ là điểm được quy định sẵn). Vì $f(x+y)=f(x)+f(y)$ nên $f$ được gọi là một phép đồng cấu. Vậy phép nhân với số nguyên (hoặc nhân với phần tử trong tập hữu hạn) được xem là một phép đồng cấu cho đường cong Elliptic khi mà $(x+y)G=xG+yG$.\n\nNgoài ra, ta cũng thấy một tính chất của hàm $f(x)=xG$ trong đường cong Elliptic là $yf(x)=xf(y)$.\n\n# Ý tưởng máy trộn giao dịch\n\nÝ tưởng về máy trộn được xây dựng dựa trên một hình thức trò chơi giải đố. Giả sử Alice tạo nên một câu đố $Q$ và gửi kèm cùng một số lượng $\\alpha$ tokens lên chương trình trên chuỗi khối. Nhiệm vụ của chương trình này là kiểm tra nếu bất kỳ ai có câu trả lời $A$ thoả mãn $Q$ sẽ được nhận $\\alpha$. Câu đố đặt ra phải được xác định là một vấn đề khó, chỉ có Alice, hoặc Bob người được Alice tiết lộ câu trả lời $A$ mới có thể giải đố và nhận về $\\alpha$.\n\nTuy nhiên, thực sự liên kết giữa ngươi gửi và người nhận vẫn chưa thật sự được cắt đứt khi mà Alice có liên kết với $Q$, $Q$ lại liên kết với $A$, và $A$ lại liên kết Bob, nên rốt cuộc vẫn là Alice gửi tiền cho Bob. Để cắt đứt liên kết này, chúng ta phải cắt đứt liên kết giữ $Q$ và $A$ bằng một cơ chế trộn.\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/3XLOU3d.png\" alt=\"mixer\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 2. Máy trộn giúp cắt đứt liên hệ giữa Q và A trong khi vẫn đám bảo chính xác quá trình kiểm tra.</p>\n\n# Hiện thực máy trộn\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/N9lWlMB.png\" alt=\"mechanism\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 3. Mô tả cơ chế trộn của một vòng trộn cho 3 câu đố.</p>\n\n**Câu đố.** Với đường cong Elliptic và điểm $G$ được quy định chung, cho $P$ là một điểm trên đường cong, xác định $x$ sao cho $P=xG$.\n\nĐể sinh ra một câu đố như trên, Alice lấy ngẫu nhiên một giá trị $x$, tính $P=xG$ và gửi $P$ cùng với, ví dụ, 1 SOL lên chương trình kiểm chứng.\n\n**Cơ chế trộn.** Phép trộn được thực hiện lặp lại nhiều vòng cho tập hợp các câu đố $[P]$, và ở mỗi vòng các bước thực hiện là như nhau. Cho $n$ máy trộn $M_{0..n-1}$, và một phép hoán vị $\\pi$, vòng trộn thứ $j$ được diễn ra như sau:\n\n1. Mỗi máy trộn $M_i$ chọn một giá trị ngẫu nhiên $z_i$, sau đó tính toán và nộp giá trị $[P]_j=\\pi(z_i[P]_{j-1})$ và $Gj=z_iG_{j-1}$ cùng với một số tiền cọc, ví dụ 10 SOL, lên chương trình kiểm chứng. Trong đó $G_0=G$ và $[P]_0=[P]$.\n2. Máy kiếm chứng sẽ chọn ngẫu nhiên một máy trộn và chấp nhận giá trị nộp từ máy trộn đó: $[P]_j=\\pi(z_i[P]_{j-1})$, $G_j=z_iG_{j-1}$.\n3. Tất cả các máy trộn không được chọn phải tiết lộ giá trị $z$ để chứng minh không ứng xử sai trong các bước trước và lấy lại 10 SOL.\n\nTa thấy bằng cách nhân với $z$ cũng như hoán vị bởi $\\pi$, vị trí của các câu hỏi đã bị thay đổi và không thể truy vết. Tuy nhiên câu trả lời vẫn không thay đổi vì $P=xG \\Leftrightarrow zP=xzG$. Càng nhiều vòng trộn được diễn ra, càng khó truy vết được giao dịch gốc.\n\nNgoài ra, các máy trộn cũng bị triệt tiêu động cơ làm sai khi mà ở xác suất bị phát hiện và mất khoảng cọc là rất cao.\n\n**Hoàn tiền.** Sau khi trải qua k lần trộn và đủ an toàn, người dùng có thể dùng $x$ để lần lượt kiểm tra $P_k$ nào tương ứng với $x$. Nộp $(x,P_k)$ lên chương trình và nhận lại 1 SOL.\n\n# Thiết kế hệ thống\n\n**Hồ câu đố.** Tương tự như Tornado.cash, hệ thống sẽ có các hồ 0.1 SOL, 1 SOL, 10 SOL, 100 SOL, 1000 SOL. Các câu đố sẽ được phân loại vào hồ tương ứng dựa trên lựa SOL được chuyển. Giả sử Alice muốn chuyển 10.1 SOL, Alice phải tạo 2 cấu đố P1, P2, trong đó P1 sẽ vào hồ 0.1 SOL và P2 sẽ vào 10 SOL.\n\n**Cụm Trộn.** Để tham gia và cụm máy trộn, các máy trộn đơn lẻ phải cọc tiền. Khi hệ thống một máy trộn cố tình gian lận, khoảng tiền cọc này sẽ bị tịch thu như 1 khoảng phạt. Mỗi hồ sẽ có một cụm trộn để thực hiện việc trộn.\n\n**Phí.** Khi nhận tiền về, người dùng phải trả một khoảng phí, ví dụ 0.0005 SOL, cho hồ tương ứng. Định kỳ khoảng phí này sẽ được chia lại cho các máy trộn trong cụm trộn.\n\n<img style=\"max-width:512px;width:100%;display:block;margin:auto;\" src=\"https://i.imgur.com/lmRIRQe.png\" alt=\"infra\"/>\n<p style=\"text-align:center;font-style:italic;\">Hình 4: Hệ thống máy trộn và mô hình phí.</p>\n\n# Lời kết\n\nHệ thống máy trộn trên dựa nhiều vào ý tưởng [mixnet](https://en.wikipedia.org/wiki/Mix_network), trong khi Tornado.cash dự nhiều vào [zero-knowledge proof](https://en.wikipedia.org/wiki/Zero-knowledge_proof), tuy vậy cả hai vẫn đạt được mục tiêu xoá vết giữa người gửi và người nhận. Zero-knowledge proof gần như không yêu cầu cụm máy trộn, tuy nhiên đòi hỏi khối lượng tính toán lớn hơn. Mixnet thì ngược lại khi mà khối lượng tính toán đơn giản nhưng yêu cầu cụm máy trộn để thực hiện các bước cần thiết.\n\n<br/><button data-tf-popup=\"Ij8yEHDC\" data-tf-iframe-props=\"title=[Vietnam Web3 Camp] Bài tập số 10\" data-tf-medium=\"snippet\" style=\"all:unset;font-family:Helvetica,Arial,sans-serif;display:inline-block;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;background-color:#F9575E;color:#FFFFFF;font-size:20px;border-radius:12px;padding:0 33px;font-weight:bold;height:50px;cursor:pointer;line-height:50px;text-align:center;margin:0;text-decoration:none;margin:auto;display:block;\">Làm bài tập</button><script src=\"//embed.typeform.com/next/embed.js\"></script>",
    "title": "Những ví dụ kinh điển trong PriFi"
  },
  "id": "34259014810"
}