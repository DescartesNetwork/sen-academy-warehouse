{
  "createdAt": 1652339540727,
  "updatedAt": 1652341098108,
  "thumbnail": "https://academy.sentre.io/static/media/pss-thumbnail.eab33090c0f4b6b621c8.png",
  "category": [
    "dev",
    "blockchain",
    "solana"
  ],
  "en": {
    "contents": "Khi tạo dựng một DApp trên Solana, bạn sẽ cần tạo SPL token tương ứng cũng như cài đặt một tài khoản/địa chỉ do chương trình quản lý (Program Derived Account/Address - PDA) nhằm tránh rủi ro cho nguồn thanh khoản của DApp. Bài viết này sẽ giúp các bạn hiểu rõ hơn về chuẩn SPLT khi tạo token, cách PDA hoạt động, cách thuê tài khoản, tạo PDA và cập nhật dữ liệu trên đó.\n\n## **SPLT Program là gì?**\n**SPL Token là fungible token**\n\n(token có thể thay thế được) trên mạng lưới blockchain Solana. Các token này được tạo ra dựa trên Solana Program Library (SPL) và được lưu trong các ví tương thích với Solana, ví dụ như ví Phantom chứa SOL, SNTR, vân vân.\n\nFungible token là một tập hợp các token chứa tất cả các thuộc tính giống hệt nhau và có thể trao đổi cho nhau. Chúng có thể phân chia được và không phải là duy nhất. Ví dụ như đồng đô la chẳng hạn: Tờ 1 đô la ở New York có giá trị tương đương với tờ 1 đô la ở Việt Nam. Một fungible token cũng có thể là một loại tiền điện tử như SOL: 1 SOL có giá trị bằng 1 SOL, bất kể nó được phát hành ở đâu.\n\n**SPL (Solana Program Library)**\n\nlà tập hợp các chương trình Solana mà đội ngũ lập trình viên Solana đã triển khai trên blockchain. SPL cũng là tiêu chuẩn kỹ thuật được sử dụng cho các Smart Contract trên mạng lưới Solana, bao gồm cả SPL Token Program.\n\nSPL Token Program được sử dụng để tạo và quản lý SPL Token bằng cách sử dụng Token Program. Điều này giúp dev đơn giản hóa việc quản lý các token, bởi tất cả những gì bạn cần làm chỉ là gửi lệnh hướng dẫn đến Token Program để mint/transfer/burn tokens.\n\n## **PDA (Program Derived Address/Account) là gì?**\nProgram Derived Address (PDA) cho phép các chương trình điều khiển một số địa chỉ nhất định và đảm bảo không một người dùng bên ngoài nào có thể tạo các giao dịch hợp lệ có chữ ký với các địa chỉ đó. Có thể hiểu rằng với PDA, các chương trình có thể ký cho các địa chỉ nhất định này mà không cần private key.\n\nKhi sử dụng một PDA, một chương trình có thể được cấp quyền cho một tài khoản và sau đó chuyển quyền này cho một tài khoản khác. Điều này khả thi vì chương trình có thể đóng vai trò là “người ký” trong giao dịch cung cấp quyền hạn.\n\nChúng ta cùng làm rõ định nghĩa trên nhé:\n\n* Ở Solana, các chương trình là stateless: Bất kỳ dữ liệu nào chúng ta cần làm việc phải được chuyển vào bằng cách tham chiếu từ bên ngoài (giống như máy tính đục lỗ) và thuê account (thuê vùng nhớ giống như đưa vào tấm bìa đục lỗ) để lưu trữ các dữ liệu.\n* Account là một nơi chứa dữ liệu (ví dụ: số token bạn đang giữ) - khi đó được gọi là “data account”, hoặc là một chương trình thực thi (ví dụ: một smart contract) - khi đó được gọi là “program account\". Tất cả trạng thái sẽ được lưu trong data account. Mỗi account là một địa chỉ duy nhất và địa chỉ đó là khóa công khai (Public Key) của một cặp khóa (Keypair) được sở hữu bởi một chương trình. Chỉ chủ sở hữu tài khoản mới có thể sửa đổi nó.\n* Khi bạn có một token thuê account như trên và đưa cho contract, nó sẽ ghi vào vị trí tương ứng và token đó sẽ thuộc quyền sở hữu của bạn. Chương trình PDA có thể giúp bạn thực hiện việc đó. Chương trình PDA không chứa Private Key, bởi nếu user nào nắm giữ Private Key này sẽ có toàn quyền sửa đổi data của account.\n* Ví dụ 1: User chỉ sở hữu 10 đồng, nhưng lại có thể tự update thành 100, 1000…\n* Ví dụ 2: Vào một ngày đẹp trời, công ty của bạn muốn biểu quyết xem nên mua pizza hay hamburger cho buổi tiệc sắp tới. Bạn cần tạo chương trình để mọi người có thể tham gia bỏ phiếu. Muốn bỏ phiếu chọn pizza hay hamburger thì cần cập nhật dữ liệu số lượng phiếu, và cần Private Key để lưu thông tin bỏ phiếu. Như vậy, chỉ người tạo ra account đó mới cập nhật được số lượng vote, và nếu công ty lưu Private Key ở đâu đó thì người có thông tin này sẽ có thể thay đổi tùy ý số phiếu bầu, như ví dụ trên. PDA sẽ giúp loại bỏ rủi ro trong trường hợp này.\n## **Cơ chế hoạt động của PDA**\nProgram address được xác định từ một tập hợp các seeds và program ID bằng cách sử dụng hàm băm SHA-256.\n\nProgram address không được nằm trên đường cong ed25519 để đảm bảo không có khoá cá nhân nào liên quan. Trong quá trình tạo, nếu địa chỉ được tìm thấy nằm trên đường cong, chương trình sẽ báo lỗi. Có khoảng 50% khả năng xảy ra lỗi này đối với một tập hợp seeds và program ID nhất định.\n\nNếu điều này xảy ra, có thể dùng một tập hợp khác của seeds hoặc seed bump (seed 8 bit bổ sung) để tìm programs address hợp lệ ngoài đường cong.\n\nVì không có khóa riêng được liên kết, người dùng bên ngoài không thể tạo chữ ký hợp lệ cho PDA.\n\nsolana\n\n![](https://lh3.googleusercontent.com/LC-KSgoBprEUveCqmQnx8nhyVZBo4d2GkC9R6U7CTXgXXrjNUli7eajRWa7bY4hdG3EhMW569AT760wnFZxGRA4WJAsKG42s98AfMKCUFHSzw3d3ncdNSvb4duOGQvcazilvQU16)\n\n\n## **Viết chương trình demo**\nGiờ chúng ta cùng thử tạo chương trình vote ăn pizza hay hamburger nhé!\n\n### **Bước 1. Tạo project**\n```ts\nanchor init demo_spl\ncd demo_spl\n```\n\n### **Bước 2. Định nghĩa cấu trúc dữ liệu**\n* Chúng ta xác định trạng thái của “vote_account” trông như thế nào.\n* VotingState là một cấu trúc có ba thuộc tính: pizza, hamburger và bump.\n* Thuộc tính “pizza” và “hamburger” sẽ theo dõi các phiếu vote tương ứng của chúng dưới dạng số nguyên dương 64-bit.\n* “bump” sẽ lưu trữ “vote_account_bump” mà chúng ta sẽ truyền vào khi khởi chạy chương trình của mình.\n* “bump” này kết hợp với “seed” tĩnh sẽ giúp mọi người dễ dàng lấy được cùng một PDA sử dụng để theo dõi trạng thái của chúng ta.\n\n\nFolder: *demospl/programs/demospl/src/lib.rs*\n\n```ts\n#[account]\npub struct VotingState {\n pub pizza: u64,n . pub hamburger: u64,\n pub bump: u8,n}\n```\n\n### **Bước 3. Khai báo các tài khoản tương tác**\n#[derive(Accounts)] chỉ định tất cả các tài khoản được yêu cầu cho một instruction nhất định. Ở đây, chúng ta xác định hai cấu trúc: Initialize và Vote.\n\n```ts\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, seeds = [b\"seed\".as_ref()], bump, payer = user, space = 8 + 16 + 1)]\n    pub vote_account: Account<'info, VotingState>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut, seeds = [b\"seed\".as_ref()], bump = vote_account.bump)]\n    vote_account: Account<'info, VotingState>,\n}\n```\n\n### **Bước 4. Khai báo các hàm thực thi**\n```ts\npub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {\n    ctx.accounts.vote_account.bump = vote_account_bump;\n    Ok(())\n}\n\npub fn vote_pizza(ctx: Context<Vote>) -> Result<()> {\n    ctx.accounts.vote_account.pizza += 1;\n    Ok(())\n}\n\npub fn vote_hamburger(ctx: Context<Vote>) -> Result<()> {\n    ctx.accounts.vote_account.hamburger += 1;\n    Ok(())\n}\n```\n   \n\nChương trình của chúng ta sẽ trông như sau:\n\n```ts\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod demo_spl {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>, vote_account_bump: u8) -> Result<()> {\n        ctx.accounts.vote_account.bump = vote_account_bump;\n        Ok(())\n    }\n\n    pub fn vote_pizza(ctx: Context<Vote>) -> Result<()> {\n        ctx.accounts.vote_account.pizza += 1;\n        Ok(())\n    }\n\n    pub fn vote_hamburger(ctx: Context<Vote>) -> Result<()> {\n        ctx.accounts.vote_account.hamburger += 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, seeds = [b\"seed\".as_ref()], bump, payer = user, space = 8 + 16 + 1)]\n    pub vote_account: Account<'info, VotingState>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Vote<'info> {\n    #[account(mut, seeds = [b\"seed\".as_ref()], bump = vote_account.bump)]\n    vote_account: Account<'info, VotingState>,\n}\n\n#[account]\npub struct VotingState {\n    pub pizza: u64,\n    pub hamburger: u64,\n    pub bump: u8,\n}\n```\n### **Bước 4. Khai báo các hàm thực thi**\n```ts\nanchor build\n```\n\nIDL:\n\n* Thông tin chương trình có thể xem trong /target/idl/demo_spl.json\n* Đây là nơi xác định chương trình của chúng ta.\n* Mỗi phương thức bên trong xác định một trình xử lý yêu cầu RPC và có thể được gọi bởi client.\n```ts\n{\n\"version\": \"0.1.0\",\n\"name\": \"demo_spl\",\n\"instructions\": [\n  {\n    \"name\": \"initialize\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      },\n      {\n        \"name\": \"user\",\n        \"isMut\": true,\n        \"isSigner\": true\n      },\n      {\n        \"name\": \"systemProgram\",\n        \"isMut\": false,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": [\n      {\n        \"name\": \"voteAccountBump\",\n        \"type\": \"u8\"\n      }\n    ]\n  },\n  {\n    \"name\": \"votePizza\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": []\n  },\n  {\n    \"name\": \"voteHamburger\",\n    \"accounts\": [\n      {\n        \"name\": \"voteAccount\",\n        \"isMut\": true,\n        \"isSigner\": false\n      }\n    ],\n    \"args\": []\n  }\n],\n\"accounts\": [\n  {\n    \"name\": \"VotingState\",\n    \"type\": {\n      \"kind\": \"struct\",\n      \"fields\": [\n        {\n          \"name\": \"pizza\",\n          \"type\": \"u64\"\n        },\n        {\n          \"name\": \"hamburger\",\n          \"type\": \"u64\"\n        },\n        {\n          \"name\": \"bump\",\n          \"type\": \"u8\"\n        }\n      ]\n    }\n  }\n]\n}\n```\n\nVới IDL chúng ta sẽ update lại test chương trình:\n\ndemo_spl.ts\n\n```ts\nimport * as anchor from \"@project-serum/anchor\";\nimport { Program } from \"@project-serum/anchor\";\nimport { DemoSpl } from \"../target/types/demo_spl\";\nconst { SystemProgram } = anchor.web3;\n\ndescribe(\"demo_spl\", async () => {\n  // Use a local provider.\n  const provider = anchor.Provider.local();\n\n  // Configure the client to use the local cluster.\n  anchor.setProvider(provider);\n\n  const program = anchor.workspace.DemoSpl as Program<DemoSpl>;\n\n\n  //Client muốn read/write account vote\n  //Bằng cách sử dụng findProgramAddress, bạn không cần phải lưu trữ Public key\n  //thay vào đó, bạn có thể dễ dàng tìm được một địa chỉ PDA nhờ vào seed, programId để thuê nó \n  //hoặc đọc và cập nhật dữ liệu\n  const [account, accountBump] = await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from(\"seed\")],\n    program.programId\n  );\n\n  it(\"Is initialized!\", async () => {\n    await program.rpc.initialize(new anchor.BN(accountBump), {\n      accounts: {\n        voteAccount: account,\n        user: provider.wallet.publicKey,\n        systemProgram: SystemProgram.programId\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.bump),\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n  it(\"Vote pizza!!!\", async () => {\n    await program.rpc.votePizza({\n      accounts: {\n        voteAccount: account\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n\n  it(\"Vote hamburger!!!\", async () => {\n    await program.rpc.voteHamburger({\n      accounts: {\n        voteAccount: account\n      }\n    });\n    const accountInfo = await program.account.votingState.fetch(account);\n    console.log(\n      \"accountInfo:\",\n      Number(accountInfo.pizza),\n      Number(accountInfo.hamburger)\n    );\n  });\n});\n```\n\n### **Bước 6. Chạy anchor test và xem kết quả**\n```ts\nanchor test\n```\n<br />\n<p align=\"center\">\n  <img src=\"https://lh4.googleusercontent.com/y3DR7GxiOi25HXTJ9ROvTvoHekDgL8z010_vq70kV2Fm4T_tG5Q8KKrG_TZs5wkcbfkXprm4u9bKcxrfVjASKsV_-8POqlZqjsMxK5V-umvHTJrny6NewnOlpENGAHz1rMjCYXJ9\">\n</p>\n\n\nKhi khởi tạo “Is initialized!”, dữ liệu bump, vote cho pizza và hamburger lần lượt là 253 0 0.\n\nKhi vote pizza “Vote pizza!!!”, dữ liệu vote cho pizza tăng lên là 1 và hamburger là 0.\n\nKhi vote hamburger “Vote hamburger!!!”, dữ liệu vote cho pizza giữ nguyên là 1 và hamburger tăng lên là 1.\n\nVậy là các bạn đã hoàn thành việc tìm hiểu về PDA, cách thuê account, tạo PDA và update dữ liệu trên PDA. Hãy xem video hướng dẫn từng bước và để lại bình luận nếu có thắc mắc nhé!\n\n## **Tài liệu tham khảo**\n1. https://spl.solana.com/\n2. https://solanacookbook.com/core-concepts/pdas.html\n3. ​​https://solana.wiki/zh-cn/docs/account-model/#account-storage\n4. https://www.brianfriel.xyz/understanding-program-derived-addresses/",
    "title": "PDA và chuẩn SPLT trong lập trình Solana"
  },
  "vn": {
    "title": "",
    "contents": ""
  }
}