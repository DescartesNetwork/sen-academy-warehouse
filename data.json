{
  "130904400097": {
    "createdAt": 1651633200923,
    "updatedAt": 1651636024778,
    "thumbnail": "",
    "category": [],
    "en": {
      "contents": "",
      "title": ""
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353825179923": {
    "createdAt": 1652327506346,
    "updatedAt": 1652328751944,
    "thumbnail": "https://academy.sentre.io/static/media/ds2-thumbnail.37b81891d1e8e3a58281.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong [Workshop 1](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev), chúng ta đã hoàn thành Solana program cho hệ thống bỏ phiếu có trọng số. Trong bài này, chúng ta sẽ cùng nhau phát triển giao diện đơn giản cũng như kết nối giao diện đó với Solana program để thực hiện việc giao tiếp cho hệ thống.\n\n\n## **Building the React App**\nTrong thư mục gốc của dự án Anchor, tạo một React app mới để ghi đè lên thư mục app hiện có:\n\n```ts\nnpx create-react-app app --template typescript\ncd app\n```\n\nTham khảo [bài số 2](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev) và [bài số 3](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev) để cài đặt ứng dụng cũng như các dependencies.\n\n\n### **Kết nối đến ví**\nỞ các bài trước, chúng ta đã tìm hiểu về Goki, cách kết nối ví và lưu thông tin ví vào Redux để có thể sử dụng, quản lý một cách hiệu quả. Tương tự như vậy, chúng ta ứng dụng lại vào chương trình và tạo kết nối đến ví người dùng.\n\n```ts\n// view/app/index.tsx\nimport { useCallback, useEffect } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { useWalletKit, useSolana, useConnectedWallet } from '@gokiprotocol/walletkit'\n\nimport { Button, Col, Layout, Row, Typography } from 'antd'\nimport ListCandidates from 'view/listCandidates'\nimport CandidateCreate from 'view/candidateCreate'\n\nimport { setWalletInfo, WalletState } from 'store/wallet.reducer'\nimport { AppDispatch } from 'store'\n\nconst { Header, Content } = Layout\n\nfunction App() {\n  const dispatch = useDispatch<AppDispatch>()\n  const wallet = useConnectedWallet()\n  const { connect } = useWalletKit()\n  const { providerMut } = useSolana()\n\n  const fetchWalletInfo = useCallback(async () => {\n    if (!wallet || !providerMut) return\n    // TODO: fetch SOL balance\n    const lamports = await providerMut.connection.getBalance(wallet.publicKey)\n    let walletInfo: WalletState = {\n      walletAddress: wallet.publicKey.toBase58(),\n      balance: lamports,\n    }\n    dispatch(setWalletInfo(walletInfo))\n  }, [providerMut, wallet])\n\n  useEffect(() => {\n    fetchWalletInfo()\n  }, [fetchWalletInfo])\n\n  return (\n    <Layout style={{ height: '100vh' }}>\n      <Header>\n        <Col span={24}>\n          {wallet ? (\n            <Col span={24} style={{ color: 'white' }}>\n              {wallet.publicKey.toBase58()}\n            </Col>\n          ) : (\n            <Button type=\"primary\" style={{ borderRadius: 40 }} onClick={connect}>\n              Connect Wallet\n            </Button>\n          )}\n        </Col>\n      </Header>\n      <Content style={{ padding: 40 }}>\n        <Row gutter={[24, 24]}>\n          <Col span={24}>\n            <Row gutter={[24, 24]}>\n              <Col flex=\"auto\">\n                <Typography.Title>List Candidates</Typography.Title>\n              </Col>\n              <Col>\n                <CandidateCreate />\n              </Col>\n            </Row>\n          </Col>\n          <Col span={24}>\n            <ListCandidates />\n          </Col>\n        </Row>\n      </Content>\n    </Layout>\n  )\n}\n\nexport default App\n```\n\n### **Giao diện bỏ phiếu**\n\n#### **Danh sách Candidate**\nGiao diện List candidates thể hiện cách thông tin: **candidate, start_date, end_date, …**\n\n\n![](https://academy.sentre.io/static/media/post-6-h1.a72f76ebb18473abedef.png)\n*Hình 1. Danh sách các ứng viên vào thông tin bỏ phiếu.*\n\n#### **Hàm khởi tạo ứng viên (New candidate)**\nGiao diện khởi tạo candidate cần các thông tin cơ bản như địa chỉ token để bỏ phiếu, ngày bắt đầu, ngày kết thúc bỏ phiếu.\n\n\n![](https://academy.sentre.io/static/media/post-6-h2.ba78517cd8d683ad0e10.png)\n*Hình 2. Giao diện khởi tạo thông tin cho ứng viên.*\n\n#### **Hàm bỏ phiếu (Vote)**\n\n\n![](https://academy.sentre.io/static/media/post-6-h3.1e5b88f42343e518990e.png)\n*Hình 3. Cử tri nhập số lượng tokens để bầu cho ứng viên.*\n\n### **Kết nối đến Solana Program (Smart Contract)**\n\nSao chép tệp **target/types/l6.ts** vào thư mục **app/config** và đặt tên **idl.ts**. Tệp này giúp định nghĩa các giao diện (interface) của Solana program. Nó giúp các chương trình off-chain, có thể là frontend hoặc backend với các ngôn ngữ khác nhau, biết các để giao tiếp với chương trình chạy on-chain. Nếu các bạn đã quen thuộc với Ethereum thì tệp IDL này có ý nghĩa tương đương với ABI.\n\nTiếp đến chúng ta phải tạo file config để định nghĩa kết nối. Cụ thể là mạng **devnet**.\n\n```ts\n// app/src/config/index.ts\nimport * as anchor from '@project-serum/anchor'\nimport { clusterApiUrl } from '@solana/web3.js'\n\nimport { IDL } from './idl'\n\nexport const DEFAULT_COMMITMENT = 'confirmed'\nexport const DEFAULT_CLUSTER = 'devnet'\nexport const PROGRAM_ADDRESS = new anchor.web3.PublicKey(\n  'HCoUastFpW7wB9Ue4o4YHy27VTuiJEo7h9hKmhnXDQhD',\n)\nexport const NODE_URL = clusterApiUrl(DEFAULT_CLUSTER)\n\nexport type CandidateData = {\n  address: string\n  mint: string\n  amount: number\n  startTime: number\n  endTime: number\n}\n\n// Function support\nexport const getProvider = (wallet: any) => {\n  const connection = new anchor.web3.Connection(NODE_URL, DEFAULT_COMMITMENT)\n  return new anchor.Provider(connection, wallet, {\n    preflightCommitment: DEFAULT_COMMITMENT,\n  })\n}\n\nexport const getProgram = (wallet: any) => {\n  const provider = getProvider(wallet)\n  return new anchor.Program(IDL, PROGRAM_ADDRESS, provider)\n}\n```\n\n\nViết hàm gọi và truyền vào các tham số định nghĩa ở IDL để tạo ứng viên\n\n```ts\nawait program.rpc.initializeCandidate(new anchor.BN(startTime), new anchor.BN(endTime), {\n  accounts: {\n    authority: wallet.publicKey,\n    candidate: candidate.publicKey,\n    treasurer,\n    mint: new anchor.web3.PublicKey(mintAddress),\n    candidateTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [candidate],\n})\n```\n\nTạo hàm bỏ phiếu cho ứng viên\n\n```ts\nawait program.rpc.vote(new anchor.BN(amount), {\n    accounts: {\n    authority: wallet.publicKey,\n    candidate: candidatePublicKey,\n    treasurer,\n    mint: candidateData.mint,\n    candidateTokenAccount,\n    ballot,\n    voterTokenAccount: walletTokenAccount,\n    tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n    systemProgram: anchor.web3.SystemProgram.programId,\n    rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n  },\n  signers: [],\n  })\n```\n\nTạo hàm close vote\n\n```ts\nawait program.rpc.close({\naccounts: {\n  authority: wallet.publicKey,\n  candidate: candidatePublicKey,\n  treasurer,\n  mint: candidateData.mint,\n  candidateTokenAccount,\n  ballot,\n  voterTokenAccount: walletTokenAccount,\n  tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n  associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,\n  systemProgram: anchor.web3.SystemProgram.programId,\n  rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n},\nsigners: [],\n})\n```\n\n## **Tham khảo**\nExample repository: [https://github.com/tuphan-dn/evoting-system](https://github.com/tuphan-dn/evoting-system)\n\nBlockchain là gì?: [https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev](https://academy.sentre.io/#/blogs/what-is-blockchain?category=dev)\n\nThiết kế giao diện DApp: [https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev](https://academy.sentre.io/#/blogs/design-dapp-ui?category=dev)\n\nQuản lý State của Dapp: [https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev](https://academy.sentre.io/#/blogs/manage-dapp-state?category=dev)\n\nViết phần mềm Solana đầu tiên: [https://academy.sentre.io/#/blogs/first-solana-program?category=dev](https://academy.sentre.io/#/blogs/first-solana-program?category=dev)\n\nPDA và chuẩn SPLT trong lập trình Solana: [https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev](https://academy.sentre.io/#/blogs/pda-and-splt-on-solana?category=dev)\n\nXây dựng DApp đầu tiên trên Solana (phần 1): [https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev](https://academy.sentre.io/#/blogs/dapp-on-solana-1?category=dev)",
      "title": "Xây dựng Solana DApp đầu tiên (P2)"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "353917979844": {
    "createdAt": 1651640470205,
    "updatedAt": 1651822151703,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [
      "user"
    ],
    "en": {
      "contents": "\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nSome useful information that you can also consider as below:\n-  ....",
      "title": "8th Post"
    },
    "vn": {
      "contents": "Tiếng việt phiên bản\n\n![](https://jes.edu.vn/wp-content/uploads/2017/10/h%C3%ACnh-%E1%BA%A3nh.jpg)\n\nCác thông tin hữu ích như dưới đây:\n-  ....",
      "title": "Bài viết số 8"
    }
  },
  "423775549517": {
    "createdAt": 1651821841184,
    "updatedAt": 1652027219201,
    "thumbnail": "http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg",
    "category": [],
    "en": {
      "contents": "Xin chao, day la bai viet thu 10, test for từ khoá developer\n\n![](http://3.bp.blogspot.com/-GxfQkICL0FI/VEMymKDVqkI/AAAAAAAAFEY/ZGi4Jp5xvMI/s1600/Rene-Descartes.jpg)",
      "title": "Bai viet thu 10"
    },
    "vn": {
      "contents": "",
      "title": ""
    },
    "id": "423775549517"
  },
  "44439736980": {
    "createdAt": 1652148385472,
    "updatedAt": 1652327451322,
    "thumbnail": "https://academy.sentre.io/static/media/defi-thumbnail.e801bf2bffd3d758200f.png",
    "category": [
      "dev"
    ],
    "en": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "vn": {
      "contents": "Trong bài này, chúng ta sẽ cùng nhau phân tích một sản phẩm DeFi điển hình: đó là **Công cụ tạo lập thị trường tự động (Automated Market Maker, hay AMM)**, cũng như hệ sinh xung quanh chính nó. Từ đó, bạn đọc sẽ có được một cái nhìn sâu sắc về kỹ thuật cũng như cách phát triển hệ sinh thái cho ý tưởng riêng của mình.\n\n## **CLOB vs AMM**\nBạn có thể ít nhiều đã nghe đến các sàn giao dịch như cổ phiếu hoặc crypto, nơi thanh khoản được tạo ra bởi chính người dùng. Thanh khoản ở đây được hiểu đơn giản như sau: Bạn muốn bán A để lấy B, và trên thị trường đang có nhiều người bán B để lấy A đối ứng. Khi giao dịch của bạn được khớp nhanh chóng với người đối ứng, thì đó là một thị trường thanh khoản tốt. Các hình thức tổ chức giao dịch như vậy được gọi là Central Limit Order Book hay CLOB. Các lệnh mua bán được tạo ra bởi chính người dùng, và việc mua bán diễn ra khi có 2 lệnh khớp nhau. Vấn đề lớn nhất đối với các sàn dạng CLOB là một số tài sản sẽ có thanh khoản kém và gần như không thể thực hiện giao dịch, hoặc giao dịch mất thời gian rất lâu để khớp lệnh đối ứng. AMM được sinh ra nhằm giải quyết vấn đề này.\n\nAMM định nghĩa sẵn một đường cong giá trị, ví dụ như cặp tài sản A/B. Người dùng được khuyến khích đặt (deposit) tiền vào trong một hồ (pool) chung để tạo thanh khoản cho AMM. Khi ấy, người tham gia sẽ trở thành nhà cung cấp thanh khoản. Khi có một giao dịch được đặt lệnh, ngay lập tức AMM sẽ dựa vào đường cong giá để tính toán lượng tài sản bán ra sẽ là bao nhiêu. Đường cong giá này sẽ đảm bảo tuân thủ theo quy luật cung cầu, cũng như tính công bằng cho cả người cung cấp thanh khoản và người giao dịch. Với mỗi giao dịch, nhà cung cấp thanh khoản sẽ nhận được một khoảng phí nhỏ làm phần thưởng cho thanh khoản họ cung cấp vào. Còn về phía nhà giao dịch, tất cả các lệnh sẽ được giao dịch ngay tức khắc. Như vậy, AMM “giả lập” một thị trường với thanh khoản rất cao.\n\n![](https://academy.sentre.io/static/media/h1-post-8.6b3cce924bd7313ec32f.png)\n*Hình 1. So sánh cơ chế giữa CLOB và AMM.*\n\n## **Đường cong giá trị (Pricing Curve)**\nĐể biểu diễn được quy luật cung cầu, đường cong giá trị nổi tiếng và được sử dụng rộng rãi hiện nay chính là hàm tích hằng (Product Constant Function). Hàm tích hằng được thể hiện như sau:\n\n**Hàm tích hằng**. Với một thị trường cho cặp A và B với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align:center\">R A × R B = k</div>\n\n\n\nGiả sử trạng thái hiện tại của thị trường là R A và có một giao dịch bán A với lượng r A . Khi này R A ′ = R A + r A đồng thời phía B sẽ chuyển sang trạng thái mới là R' B sao cho:\n\n<div style=\"text-align:center\">R A × R B = R A ′ × R B ′ = k</div>\n\nBằng công thức, chúng ta có thể tính toán được R' B sau đó tính được lượng r b = R B − R B ′ trả ra cho người giao dịch.\n\n![](https://academy.sentre.io/static/media/h2-post-8.a16794e21f8ca8d426b2.png)\n*Hình 2. Đường cong giá trị xy=1.*\n\nGọi giá của thị trường của A và B là p, khi đó p = R A ÷ R B\n\nVới ví dụ bên trên, khi nhà giao dịch bán A để lấy B, điều đó đồng nghĩa với việc lượng A trong hồ sẽ nhiều hơn và lượng B sẽ ít đi. Lúc này giá cả sau giao dịch sẽ tăng, cụ thể hơn là nhà giao dịch cần nhiều A hơn để mua cùng một lượng B với các giao dịch tiếp theo.\n\n\n## **Token thanh khoản (Liquidity Provision Token)**\n\nNhư đã nhắc ở trên, với mỗi giao dịch sẽ có một lượng phí nhỏ được thu và chia lại theo tỷ lệ cho các nhà cung cấp thanh khoản. Vấn đề đặt ra là hệ thống cần tổ chức một cơ chế ghi nhận số lượng thanh khoản mỗi cá nhân đã cung cấp. Cơ chế token hoá (tokenization) hiện tại là giải pháp hữu hiệu nhất. Với mỗi cặp token thanh khoản được cung cấp, nhà cung cấp thanh khoản sẽ được nhận lại một số lượng token thanh khoản (hay còn gọi là LP token) để bảo chứng cho số lượng thanh khoản đã được cung cấp vào AMM.\n\n**Token thanh khoản**. Một cá nhân cung cấp thanh khoản với số lượng R A và R B cho thị trường, số lượng token thanh khoản nhận lại sẽ là:\n\n<div style=\"text-align: center\">L P = R A × R B</div>\n\nLưu ý ở đây rằng khi cung cấp hoặc rút thanh khoản, giá trị k trong hàm tích hằng phải được thay đổi để phù hợp với trạng thái mới của thanh khoản trong thị trường.\n\nLP cũng là token có giá trị, khi giá trị của LP được neo với 2 token A và B trong hồ. Do đó, ta có thể xem LP như một sản phẩm phái sinh có thể trao đổi được trong tương lai, tương tự như hợp đồng nợ, hợp đồng quyền chọn, vân vân.\n\n## **Các dạng thức khác của hàm tích hằng**\n### **Hàm tích hằng tổng quát**\nHàm tích hằng ở trên chỉ có thể áp dụng cho 2 tài sản trong một hồ, và đặt biệt hai tài sản này phải có tổng giá trị quy đổi ngang bằng nhau. Trong thực tế, nhu cầu về cấu trúc hồ phức tạp hơn rất nhiều như thế khi mà số lượng tài sản có thể là 3, 4 hoặc thậm chí 10. Các hồ lệch cũng cần thiết trong một số tình huống (hồ lệch khi giá trị quy đổi của các tài sản trong hồ là không bằng nhau). Vì vậy, hàm tích hằng tổng quát ra đời nhằm đáp ứng các nhu cầu này.\n\nHàm tích hằng tổng quát. Với một thị trường cho nhóm n tài sản A 1.. n với lượng thanh khoản cho trước là R 1.. n tất cả các giao dịch phải tuân theo:\n\n<div style=\"text-align: center\">∑ i = 1 n R i ω i = k</div>\n\nTrong đó ω i là trọng số điều chỉnh độ lệch của tài sản trong hồ.\n\nSo với hàm tích hằng đơn thuần, hàm tích hằng tổng quát cho phép nhiều tài sản cùng xây dựng một hồ. Hơn thế, giá trị quy đổi của các tài sản trong hồ được điều chỉnh thông qua trọng số. Điều này giúp điều chỉnh hồ lại về thế cân bằng theo lý thuyết tính toán.\n\n**Hàm tích hằng khuếch đại**. Với một thị trường cho cặp tài sản A và B có giá trị quy đổi không biến thiên hoặc biến thiên rất nhỏ so với nhau, với lượng thanh khoản cho trước là R A và R B , tất cả các giao dịch phải tuân theo:\n\nγ A R A × γ B R B = k\n\nTrong đó γ A , γ B là hệ số khuếch đại trong hồ.\n\nCặp tài sản không biến thiên hoặc biến thiên rất ít thường là các cặp token ổn định (stable token) ví dụ như USDC-USDT đều có giá trị loanh quoanh \\$1. Nếu ta sử dụng hàm tích hằng đơn thuần, một lượng lớn thanh khoản trải dài trên khoản giá từ \\$1 đến ∞ và sẽ hiếm khi được sử dụng đến, gây ra lãng phí thanh khoản. Bằng các hệ số γ , hàm tích hằng khuếch đại sẽ “nén” thanh khoản về vùng giá hiệu quả, là $1 cho ví dụ của cặp USDC-USDT. Nhờ đó thanh khoản được sử dụng hiểu quả và giảm thiểu trượt giá hơn.\n\n\n## **Lưu ý khi xây dựng chương trình**\n### **Tràn số**\nThông thường số lượng token trên Solana được lưu dưới kiểu u64. Nghĩa là các phép tính nhân trong công thức tích hằng chỉ an toàn trên kiểu u128.\n\n\n### **Làm tròn**\nLàm tròn quá bán là một lựa chọn đơn giản và phổ biến trong đời sống hằng ngày, nhưng nó lại rất nguy hiểm trong các ứng dụng DeFi. Vì các tính toán trong chương trình trên blockchain đều được ưu tiên tính toán bằng số nguyên, nghĩa là việc làm tròn “không chiến lược” có thể dẫn đến hiện tượng sai lệch và có thể bị tấn công trong một số tình huống nhất định.\n\nHãy cùng quan sát ví dụ sau đây. Trong chương trình hiện đang có 11 token, A và B viết một chương trình chia đôi lượng tài sản này. Theo lẽ dĩ nhiên mỗi người sẽ nhận được 5.5 token. Tuy nhiên vì chương trình thực hiện tính toán dựa trên số nguyên và làm tròn quá bán (hoặc làm tròn lên) nên số token mỗi người sẽ nhận là 6. Tổng cả A và B sẽ là 12 trong khi tài khoản chương trình chỉ có 11. Việc này dẫn đến số tài sản này không thể được rút và khoá vĩnh viễn.\n\nViệc xác định chiến lược làm tròn rất quan trọng, bạn đọc cần dựa trên tính chất chương trình của mình để đưa ra quyết định phù hợp nhất.\n\n\n### **Tấn công Re-Entrancy**\n\nĐây là một kiểu tấn công rất phổ biến ở trong lập trình DeFi. Hãy quan sát ví dụ sau, một trương trình thực hiện việc chuyển tiền với các bước như sau:\n\n* Bước 1: Kiểm tra số dư\n* Bước 2: Chuyển tiền\n* Bước 3: Cập nhật số dư mới trong hồ\n\nỞ bước 1, việc chuyển tiền được Solana Program của bạn gọi qua SPL Program tuy nhiên “attacker” lại điều hướng sang một Solana Program khác để tiếp tục gọi lại chương trình của bạn. Lúc này, vì bước 2 chưa thực hiện xong nên số dư vẫn chưa được cập nhật. Vì vậy ở lần gọi thứ 2, kiểm tra số dư vẫn cho ra kết quả hợp lệ và tiếp tục thực hiện việc chuyển tiền.\n\nKiểu tấn công trên thường rất phổ biến trên Ethereum do cơ chế gọi hàm fallback. May thay, ở Solana vẫn chưa ghi nhận vụ tấn công nào sử dụng thủ thuật trên, tuy nhiên không vì thế mà khi viết chương trình chúng ta có thể bỏ qua lỗ hổng này.\n\n\n### **Thiếu kiểm tra account**\n\nThông thường một tài khoản (account) được thuê và định danh bởi rất nhiều thông tin. Ví dụ như một hồ được tạo ra có thể chứa nhiều thông tin về loại token trong hồ. Vì cơ chế không-trạng-thái (stateless), các tài khoản này sẽ được truyền lên bởi người dùng trong giao dịch liên quan. “Attacker” có thể lợi dụng để truyền các tài khoản không chính xác để khai thác lỗ hổng nếu chương trình thiếu đi các cơ chế kiểm tra đầy đủ. Các vụ tấn công nổi tiếng dùng cơ chế này diễn ra gần đây như Cashio, Wormhole, vân vân.\n\n\n## **Hơn cả một AMM**\nNhư đã đề cập ở trên, LP có thể được xem là sản phẩm phái sinh và có giá trị thực. Các LP này có thể được sử dụng như là đầu vào cho các sản phẩm tài chính khác.\n\n\n### **Gửi tiết kiệm (Farming, Staking)**\n\nHiện nay có nhiều giao thức cho phép nhà cung cấp thanh khoản khoán LP vào trong một hồ mới nhằm đào hoặc khai thác những token khác. Nhà cung cấp thành khoản có thể sinh ra nhiều lợi nhuận hơn, bên cạnh phí từ các hồ thanh khoản trong AMM.\n\n\n### **Thế chấp**\n\nỨng dụng tiếp theo của LP có thể được dùng để thế chấp và vay những token khác. Có 2 cơ chế vay khá phổ biến. Một là vay các token có sẵn ví như ETH, wSOL, vân vân. Hai là vay một token ổn định (stable token) - các token này thường có giá trị $1 và được đúc ra tương ứng với lượng LP khoá vào.\n\n\n### **Quỹ chỉ số**\n\nỞ mô hình hàm tích hằng tổng quát, số lượng token có thể nhiều hơn 2. Khi đó LP được xem như một token đại diện cho “rổ” đầu tư. Thay vì mua một token duy nhất, người dùng có thể tham khảo mua một nhóm các token mạnh. Bạn không nhất thiết phải mua từng token một, mà chỉ cần mua LP cho hồ đại diện rổ token bạn muốn.\n\n\n### **Lời kết**\nQua bài viết, hi vọng bạn đọc đã có một cái nhìn tổng quát về AMM cũng như hệ sinh thái xung quanh một giao thức. Để xây dựng một giao thức thành công, các nhà sáng lập không chỉ cần xây dựng một hệ thống tốt, mà còn phải xây dựng một hệ thống có thể kết nối với các sinh thái xung quanh nó để tối đa hoá tài nguyên, cũng như mở rộng quy mô.",
      "title": "Những ví dụ kinh điển về DeFi"
    },
    "id": "44439736980"
  },
  "597285154092": {
    "createdAt": 1651638928963,
    "updatedAt": 1651639515583,
    "thumbnail": "https://s3-ap-southeast-1.amazonaws.com/images.spiderum.com/sp-thumbnails/17bc1240123911ec9ed81183f1a09504.png",
    "category": [],
    "en": {
      "contents": "Helo, this is 7th file",
      "title": "test 7th file"
    },
    "vn": {
      "title": "",
      "contents": ""
    }
  },
  "675051513086": {
    "createdAt": 1650971499311,
    "updatedAt": 1650971499311,
    "thumbnail": "",
    "category": [],
    "en": {
      "title": "Tiêu đề",
      "contents": "## Fig.1. World Map\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    },
    "vn": {
      "title": "Tiêu đề",
      "contents": "## Hình 1. Bản đồ thế giới\n\n![worldmap](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)"
    }
  },
  "739403395833": {
    "createdAt": 1651114236809,
    "updatedAt": 1652243050187,
    "thumbnail": "https://lh3.googleusercontent.com/LC-KSgoBprEUveCqmQnx8nhyVZBo4d2GkC9R6U7CTXgXXrjNUli7eajRWa7bY4hdG3EhMW569AT760wnFZxGRA4WJAsKG42s98AfMKCUFHSzw3d3ncdNSvb4duOGQvcazilvQU16",
    "category": [
      "Developer",
      "dev"
    ],
    "en": {
      "contents": "# Jobs Opportunity\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. World map*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. The same world map*\n\nTest: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Jobs Opportunity"
    },
    "vn": {
      "contents": "# Cơ hội nghề nghiệp\n![World map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.1. Bản đồ thế giới*\n\n![The same world map](https://cdn.statcdn.com/Infographic/images/normal/27069.jpeg)\n*Fig.2. Bản đồ thế giới tương tự*\n\nKiểm thử: Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n\n```ts\nanchor init demo_spl\ncd demo_spl\n```",
      "title": "Cơ hội nghề nghiệp"
    },
    "id": "739403395833"
  }
}